"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[296],{3480:e=>{for(var r=/[\\\"\x00-\x1F]/g,t={},i=0;i<32;++i)t[String.fromCharCode(i)]="\\U"+("0000"+i.toString(16)).slice(-4).toUpperCase();function n(e){return r.lastIndex=0,e.replace(r,function(e){return t[e]})}t["\b"]="\\b",t["	"]="\\t",t["\n"]="\\n",t["\f"]="\\f",t["\r"]="\\r",t['"']='\\"',t["\\"]="\\\\",e.exports={stringify:function e(r){switch(typeof r){case"string":return'"'+n(r)+'"';case"number":return isFinite(r)?r:"null";case"boolean":return r;case"object":if(null===r)return"null";if(Array.isArray(r)){for(var t=r,i="[",o="",s=0;s<t.length;++s)o+=i,i=",",o+=e(t[s]);return","!=i?"[]":o+"]"}return function(r){var t="{",i="",o=Object.keys(r);o.sort();for(var s=0;s<o.length;++s){var a=o[s];i+=t+'"'+n(a)+'":',t=",",i+=e(r[a])}return","!=t?"{}":i+"}"}(r);default:throw Error("Cannot stringify: "+typeof r)}}}},74802:(e,r,t)=>{e.exports=t.p+"static/media/matrix_sdk_crypto_wasm_bg.c359cf28.wasm"},85296:(e,r,t)=>{t.r(r),t.d(r,{initRustCrypto:()=>eK});var i=t(84458),n=t(29301),o=t(34051);let s=new t.U(t(74802));o.__wbg_set_wasm(new Proxy({},{get(){throw Error("@matrix-org/matrix-sdk-crypto-wasm was used before it was initialized. Call `initAsync` first.")}}));let a=null;async function c(e){let{instance:r}=await WebAssembly.instantiateStreaming(fetch(e),{"./matrix_sdk_crypto_wasm_bg.js":o});o.__wbg_set_wasm(r.exports),r.exports.__wbindgen_start()}async function u(e=s){a||(a=c(e)),await a}var d=t(3480),l=t(5294),g=t(82393),y=t(70489),h=t(5408),p=t(36963),v=t(9086),f=t(84656),m=t(11749),k=t(37858);class S{constructor(e,r,t,n,s,a){this.prefixedLogger=e,this.olmMachine=r,this.keyClaimManager=t,this.outgoingRequestManager=n,this.room=s,this.encryptionSettings=a,(0,i.A)(this,"lazyLoadedMembersResolved",!1),(0,i.A)(this,"currentEncryptionPromise",Promise.resolve());var c=s.getJoinedMembers();this.olmMachine.updateTrackedUsers(c.map(e=>new o.UserId(e.userId))).catch(e=>this.prefixedLogger.error("Error initializing tracked users",e))}onCryptoEvent(e){if(JSON.stringify(this.encryptionSettings)!=JSON.stringify(e))throw Error("Cannot reconfigure an active RoomEncryptor")}onRoomMembership(e){(e.membership==l.O.Join||e.membership==l.O.Invite&&this.room.shouldEncryptForInvitedMembers())&&this.olmMachine.updateTrackedUsers([new o.UserId(e.userId)]).catch(e=>{this.prefixedLogger.error("Unable to update tracked users",e)})}prepareForEncryption(e,r){var t=this;return(0,n.A)(function*(){yield t.encryptEvent(null,e,r)})()}encryptEvent(e,r,t){var i,o=this,s=new h.Tl(this.prefixedLogger,e?null!=(i=e.getTxnId())?i:"":"prepareForEncryption"),a=this.currentEncryptionPromise.catch(()=>{}).then((0,n.A)(function*(){yield(0,m.NQ)(s,"ensureEncryptionSession",(0,n.A)(function*(){yield o.ensureEncryptionSession(s,r,t)})),e&&(yield(0,m.NQ)(s,"encryptEventInner",(0,n.A)(function*(){yield o.encryptEventInner(s,e)})))}));return this.currentEncryptionPromise=a,a}ensureEncryptionSession(e,r,t){var i=this;return(0,n.A)(function*(){if("m.megolm.v1.aes-sha2"!==i.encryptionSettings.algorithm)throw Error("Cannot encrypt in ".concat(i.room.roomId," for unsupported algorithm '").concat(i.encryptionSettings.algorithm,"'"));e.debug("Starting encryption");var s=yield i.room.getEncryptionTargetMembers();i.lazyLoadedMembersResolved?(e.debug("Processing outgoing requests in background"),i.outgoingRequestManager.doProcessOutgoingRequests()):(yield(0,m.NQ)(e,"loadMembersIfNeeded: updateTrackedUsers",(0,n.A)(function*(){yield i.olmMachine.updateTrackedUsers(s.map(e=>new o.UserId(e.userId)))})),e.debug("Updated tracked users"),i.lazyLoadedMembersResolved=!0,e.debug("Processing outgoing requests"),yield(0,m.NQ)(e,"doProcessOutgoingRequests",(0,n.A)(function*(){yield i.outgoingRequestManager.doProcessOutgoingRequests()}))),e.debug("Encrypting for users (shouldEncryptForInvitedMembers: ".concat(i.room.shouldEncryptForInvitedMembers(),"):"),s.map(e=>"".concat(e.userId," (").concat(e.membership,")")));var a=s.map(e=>new o.UserId(e.userId));yield(0,m.NQ)(e,"ensureSessionsForUsers",(0,n.A)(function*(){yield i.keyClaimManager.ensureSessionsForUsers(e,a)}));var c=new o.EncryptionSettings;switch(c.historyVisibility=function(e){switch(e){case f.Jv.Invited:return o.HistoryVisibility.Invited;case f.Jv.Joined:return o.HistoryVisibility.Joined;case f.Jv.Shared:return o.HistoryVisibility.Shared;case f.Jv.WorldReadable:return o.HistoryVisibility.WorldReadable}}(i.room.getHistoryVisibility()),c.algorithm=o.EncryptionAlgorithm.MegolmV1AesSha2,"number"==typeof i.encryptionSettings.rotation_period_ms&&(c.rotationPeriod=BigInt(1e3*i.encryptionSettings.rotation_period_ms)),"number"==typeof i.encryptionSettings.rotation_period_msgs&&(c.rotationPeriodMessages=BigInt(i.encryptionSettings.rotation_period_msgs)),t.kind){case k.YH.AllDevicesIsolationMode:var u,d=null!=(u=i.room.getBlacklistUnverifiedDevices())?u:r;c.sharingStrategy=o.CollectStrategy.deviceBasedStrategy(d,t.errorOnVerifiedUserProblems);break;case k.YH.OnlySignedDevicesIsolationMode:c.sharingStrategy=o.CollectStrategy.identityBasedStrategy()}yield(0,m.NQ)(e,"shareRoomKey",(0,n.A)(function*(){var e=yield i.olmMachine.shareRoomKey(new o.RoomId(i.room.roomId),a,c);if(e)for(var r of e)yield i.outgoingRequestManager.outgoingRequestProcessor.makeOutgoingRequest(r)}))})()}forceDiscardSession(){var e=this;return(0,n.A)(function*(){(yield e.olmMachine.invalidateGroupSession(new o.RoomId(e.room.roomId)))&&e.prefixedLogger.info("Discarded existing group session")})()}encryptEventInner(e,r){var t=this;return(0,n.A)(function*(){e.debug("Encrypting actual message content");var i,n=new o.RoomId(t.room.roomId),s=r.getType(),a=JSON.stringify(r.getContent());i=r.isState()?yield t.olmMachine.encryptStateEvent(n,s,r.getStateKey(),a):yield t.olmMachine.encryptRoomEvent(n,s,a),r.makeEncrypted(v.Bx.RoomMessageEncrypted,JSON.parse(i),t.olmMachine.identityKeys.curve25519.toBase64(),t.olmMachine.identityKeys.ed25519.toBase64()),e.debug("Encrypted event successfully")})()}}var b=t(35095),R=t(15095),w="/_matrix/client/unstable/org.matrix.msc3814.v1",I="org.matrix.msc3814";class K extends R.X{constructor(e,r,t,n,o){super(),this.logger=e,this.olmMachine=r,this.http=t,this.outgoingRequestProcessor=n,this.secretStorage=o,(0,i.A)(this,"intervalId",void 0)}cacheKey(e){var r=this;return(0,n.A)(function*(){yield r.olmMachine.dehydratedDevices().saveDehydratedDeviceKey(e),r.emit(k.cr.DehydrationKeyCached)})()}isSupported(){var e=this;return(0,n.A)(function*(){try{yield e.http.authedRequest(p.IT.Get,"/dehydrated_device",void 0,void 0,{prefix:w})}catch(e){if("M_UNRECOGNIZED"===e.errcode)return!1;if("M_NOT_FOUND"===e.errcode)return!0;throw e}return!0})()}start(){var e=arguments,r=this;return(0,n.A)(function*(){var t=e.length>0&&void 0!==e[0]?e[0]:{};if("boolean"==typeof t&&(t={createNewKey:t}),!t.onlyIfKeyCached||(yield r.olmMachine.dehydratedDevices().getDehydratedDeviceKey())){if(r.stop(),!1!==t.rehydrate)try{yield r.rehydrateDeviceIfAvailable()}catch(e){r.logger.info("dehydration: Error rehydrating device:",e),r.emit(k.cr.RehydrationError,e.message)}t.createNewKey&&(yield r.resetKey()),yield r.scheduleDeviceDehydration()}})()}isKeyStored(){var e=this;return(0,n.A)(function*(){return!!(yield e.secretStorage.isStored(I))})()}resetKey(){var e=this;return(0,n.A)(function*(){var r=o.DehydratedDeviceKey.createRandomKey();return yield e.secretStorage.store(I,r.toBase64()),yield e.cacheKey(r),r})()}getKey(e){var r=this;return(0,n.A)(function*(){var t=yield r.olmMachine.dehydratedDevices().getDehydratedDeviceKey();if(t)return t;var i=yield r.secretStorage.get(I);if(void 0===i)return e?yield r.resetKey():null;var n=(0,b.y4)(i);try{var s=o.DehydratedDeviceKey.createKeyFromArray(n);return yield r.cacheKey(s),s}finally{n.fill(0)}})()}rehydrateDeviceIfAvailable(){var e=this;return(0,n.A)(function*(){var r,t=yield e.getKey(!1);if(!t)return!1;try{r=yield e.http.authedRequest(p.IT.Get,"/dehydrated_device",void 0,void 0,{prefix:w})}catch(r){if("M_NOT_FOUND"===r.errcode||"M_UNRECOGNIZED"===r.errcode)return e.logger.info("dehydration: No dehydrated device"),!1;throw r}e.logger.info("dehydration: dehydrated device found"),e.emit(k.cr.RehydrationStarted);var i=yield e.olmMachine.dehydratedDevices().rehydrate(t,new o.DeviceId(r.device_id),JSON.stringify(r.device_data));e.logger.info("dehydration: device rehydrated");for(var n=void 0,s=0,a=0,c=(0,m.RR)("/dehydrated_device/$device_id/events",{$device_id:r.device_id});;){var u=yield e.http.authedRequest(p.IT.Post,c,void 0,n?{next_batch:n}:{},{prefix:w});if(0===u.events.length)break;s+=u.events.length,n=u.next_batch,a+=(yield i.receiveEvents(JSON.stringify(u.events))).length,e.emit(k.cr.RehydrationProgress,a,s)}return e.logger.info("dehydration: received ".concat(a," room keys from ").concat(s," to-device events")),e.emit(k.cr.RehydrationCompleted),!0})()}createAndUploadDehydratedDevice(){var e=this;return(0,n.A)(function*(){var r=yield e.getKey(!0),t=yield e.olmMachine.dehydratedDevices().create();e.emit(k.cr.DehydratedDeviceCreated);var i=yield t.keysForUpload("Dehydrated device",r);yield e.outgoingRequestProcessor.makeOutgoingRequest(i),e.emit(k.cr.DehydratedDeviceUploaded),e.logger.info("dehydration: uploaded device")})()}scheduleDeviceDehydration(){var e=this;return(0,n.A)(function*(){e.stop(),yield e.createAndUploadDehydratedDevice(),e.intervalId=setInterval(()=>{e.createAndUploadDehydratedDevice().catch(r=>{e.emit(k.cr.DehydratedDeviceRotationError,r.message),e.logger.error("Error creating dehydrated device:",r)})},6048e5)})()}stop(){this.intervalId&&(clearInterval(this.intervalId),this.intervalId=void 0)}delete(){var e=this;return(0,n.A)(function*(){e.stop();try{yield e.http.authedRequest(p.IT.Delete,"/dehydrated_device",void 0,{},{prefix:w})}catch(e){if("M_UNRECOGNIZED"===e.errcode||"M_NOT_FOUND"===e.errcode)return;throw e}})()}}function E(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);r&&(i=i.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,i)}return t}class M{constructor(e,r,t){this.logger=e,this.olmMachine=r,this.http=t}makeOutgoingRequest(e,r){var t=this;return(0,n.A)(function*(){var i;if(e instanceof o.KeysUploadRequest)i=yield t.requestWithRetry(p.IT.Post,"/_matrix/client/v3/keys/upload",{},e.body);else if(e instanceof o.KeysQueryRequest)i=yield t.requestWithRetry(p.IT.Post,"/_matrix/client/v3/keys/query",{},e.body);else if(e instanceof o.KeysClaimRequest)i=yield t.requestWithRetry(p.IT.Post,"/_matrix/client/v3/keys/claim",{},e.body);else if(e instanceof o.SignatureUploadRequest)i=yield t.requestWithRetry(p.IT.Post,"/_matrix/client/v3/keys/signatures/upload",{},e.body);else if(e instanceof o.KeysBackupRequest)i=yield t.requestWithRetry(p.IT.Put,"/_matrix/client/v3/room_keys/keys",{version:e.version},e.body);else if(e instanceof o.ToDeviceRequest)i=yield t.sendToDeviceRequest(e);else if(e instanceof o.RoomMessageRequest){var s="/_matrix/client/v3/rooms/".concat(encodeURIComponent(e.room_id),"/send/")+"".concat(encodeURIComponent(e.event_type),"/").concat(encodeURIComponent(e.txn_id));i=yield t.requestWithRetry(p.IT.Put,s,{},e.body)}else{if(e instanceof o.UploadSigningKeysRequest)return void(yield t.makeRequestWithUIA(p.IT.Post,"/_matrix/client/v3/keys/device_signing/upload",{},e.body,r));if(e instanceof o.PutDehydratedDeviceRequest)return void(yield t.rawJsonRequest(p.IT.Put,w+"/dehydrated_device",{},e.body));t.logger.warn("Unsupported outgoing message",Object.getPrototypeOf(e)),i=""}if(e.id)try{yield(0,m.NQ)(t.logger,"Mark Request as sent ".concat(e.type),(0,n.A)(function*(){yield t.olmMachine.markRequestAsSent(e.id,e.type,i)}))}catch(e){if(e instanceof Error&&("Attempt to use a moved value"===e.message||"null pointer passed to rust"===e.message))t.logger.debug("Ignoring error '".concat(e.message,"': client is likely shutting down"));else throw e}else t.logger.trace("Outgoing request type:".concat(e.type," does not have an ID"))})()}sendToDeviceRequest(e){var r=this;return(0,n.A)(function*(){var t=JSON.parse(e.body),i=[];for(var[n,o]of Object.entries(t.messages))for(var[s,a]of Object.entries(o))i.push("".concat(n,"/").concat(s," (msgid ").concat(a[v.wt],")"));r.logger.info("Sending batch of to-device messages. type=".concat(e.event_type," txnid=").concat(e.txn_id),i);var c="/_matrix/client/v3/sendToDevice/".concat(encodeURIComponent(e.event_type),"/")+encodeURIComponent(e.txn_id);return yield r.requestWithRetry(p.IT.Put,c,{},e.body)})()}makeRequestWithUIA(e,r,t,o,s){var a=this;return(0,n.A)(function*(){if(!s)return yield a.requestWithRetry(e,r,t,o);var c,u=JSON.parse(o),d=(c=(0,n.A)(function*(n){var o=function(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?E(Object(t),!0).forEach(function(r){(0,i.A)(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):E(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}({},u);return null!==n&&(o.auth=n),JSON.parse((yield a.requestWithRetry(e,r,t,JSON.stringify(o))))}),function(e){return c.apply(this,arguments)});return JSON.stringify((yield s(d)))})()}requestWithRetry(e,r,t,i){var o=this;return(0,n.A)(function*(){for(var n=0;;)try{return yield o.rawJsonRequest(e,r,t,i)}catch(e){n++;var s=(0,p.fZ)(e,n,!0);if(s<0)throw e;yield(0,m.yy)(s)}})()}rawJsonRequest(e,r,t,i){var o=this;return(0,n.A)(function*(){return yield o.http.authedRequest(e,r,t,i,{json:!1,headers:{"Content-Type":"application/json",Accept:"application/json"},prefix:"",localTimeoutMs:6e4})})()}}class A{constructor(e,r){this.olmMachine=e,this.outgoingRequestProcessor=r,(0,i.A)(this,"currentClaimPromise",void 0),(0,i.A)(this,"stopped",!1),this.currentClaimPromise=Promise.resolve()}stop(){this.stopped=!0}ensureSessionsForUsers(e,r){var t=this.currentClaimPromise.catch(()=>{}).then(()=>this.ensureSessionsForUsersInner(e,r));return this.currentClaimPromise=t,t}ensureSessionsForUsersInner(e,r){var t=this;return(0,n.A)(function*(){if(t.stopped)throw Error("Cannot ensure Olm sessions: shutting down");e.info("Checking for missing Olm sessions");var i=yield t.olmMachine.getMissingSessions(r.map(e=>e.clone()));i&&(e.info("Making /keys/claim request"),yield t.outgoingRequestProcessor.makeOutgoingRequest(i)),e.info("Olm sessions prepared")})()}}var _=t(12965),C=t(3662);class D{constructor(e,r,t,i){this.logger=e,this.olmMachine=r,this.outgoingRequestProcessor=t,this.secretStorage=i}bootstrapCrossSigning(e){var r=this;return(0,n.A)(function*(){if(e.setupNewCrossSigning)return void(yield r.resetCrossSigning(e.authUploadDeviceSigningKeys));var t=yield r.olmMachine.crossSigningStatus(),i=yield r.secretStorage.get("m.cross_signing.master"),n=yield r.secretStorage.get("m.cross_signing.self_signing"),o=yield r.secretStorage.get("m.cross_signing.user_signing"),s=!!(i&&n&&o),a=t.hasMaster&&t.hasUserSigning&&t.hasSelfSigning;if(r.logger.debug("bootstrapCrossSigning: starting",{setupNewCrossSigning:e.setupNewCrossSigning,olmDeviceHasMaster:t.hasMaster,olmDeviceHasUserSigning:t.hasUserSigning,olmDeviceHasSelfSigning:t.hasSelfSigning,privateKeysInSecretStorage:s}),a)(yield r.secretStorage.hasKey())?s?r.logger.debug("bootstrapCrossSigning: Olm device has private keys and they are saved in secret storage; doing nothing"):(r.logger.debug("bootstrapCrossSigning: Olm device has private keys: exporting to secret storage"),yield r.exportCrossSigningKeysToStorage()):r.logger.warn("bootstrapCrossSigning: Olm device has private keys, but secret storage is not yet set up; doing nothing for now.");else if(s){r.logger.debug("bootstrapCrossSigning: Cross-signing private keys not found locally, but they are available in secret storage, reading storage and caching locally");var c=yield r.olmMachine.importCrossSigningKeys(i,n,o);if(!c.hasMaster||!c.hasSelfSigning||!c.hasUserSigning)throw Error("importCrossSigningKeys failed to import the keys");var u=yield r.olmMachine.getDevice(r.olmMachine.userId,r.olmMachine.deviceId);try{var d=yield u.verify();yield r.outgoingRequestProcessor.makeOutgoingRequest(d)}finally{u.free()}}else r.logger.debug("bootstrapCrossSigning: Cross-signing private keys not found locally or in secret storage, creating new keys"),yield r.resetCrossSigning(e.authUploadDeviceSigningKeys);r.logger.debug("bootstrapCrossSigning: complete")})()}resetCrossSigning(e){var r=this;return(0,n.A)(function*(){var t=yield r.olmMachine.bootstrapCrossSigning(!0);for(var i of((yield r.secretStorage.hasKey())?(r.logger.debug("resetCrossSigning: exporting private keys to secret storage"),yield r.exportCrossSigningKeysToStorage()):r.logger.warn("resetCrossSigning: Secret storage is not yet set up; not exporting keys to secret storage yet."),r.logger.debug("resetCrossSigning: publishing public keys to server"),[t.uploadKeysRequest,t.uploadSigningKeysRequest,t.uploadSignaturesRequest]))i&&(yield r.outgoingRequestProcessor.makeOutgoingRequest(i,e))})()}exportCrossSigningKeysToStorage(){var e=this;return(0,n.A)(function*(){var r=yield e.olmMachine.exportCrossSigningKeys();null!=r&&r.masterKey?yield e.secretStorage.store("m.cross_signing.master",r.masterKey):e.logger.error("Cannot export MSK to secret storage, private key unknown"),null!=r&&r.self_signing_key?yield e.secretStorage.store("m.cross_signing.self_signing",r.self_signing_key):e.logger.error("Cannot export SSK to secret storage, private key unknown"),null!=r&&r.userSigningKey?yield e.secretStorage.store("m.cross_signing.user_signing",r.userSigningKey):e.logger.error("Cannot export USK to secret storage, private key unknown")})()}}function O(e){return B.apply(this,arguments)}function B(){return(B=(0,n.A)(function*(e){return function(e,r){return q.apply(this,arguments)}(e,["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"])})).apply(this,arguments)}function q(){return(q=(0,n.A)(function*(e,r){var t=yield e.getDefaultKeyId();if(!t)return!1;for(var i of r)if(!(t in((yield e.isStored(i))||{})))return!1;return!0})).apply(this,arguments)}var T=t(56662),P=t(75525),U=function(e){return e.Sas="m.sas.v1",e.ShowQrCode="m.qr_code.show.v1",e.ScanQrCode="m.qr_code.scan.v1",e.Reciprocate="m.reciprocate.v1",e}({});class V extends R.X{constructor(e,r,t,o,s){super(),this.logger=e,this.olmMachine=r,this.inner=t,this.outgoingRequestProcessor=o,this.supportedVerificationMethods=s,(0,i.A)(this,"reEmitter",void 0),(0,i.A)(this,"_accepting",!1),(0,i.A)(this,"_cancelling",!1),(0,i.A)(this,"_verifier",void 0),this.reEmitter=new P.Q(this);var a=new WeakRef(this);t.registerChangesCallback((0,n.A)(function*(){var e;return null==(e=a.deref())?void 0:e.onChange()}))}onChange(){var e=this.inner.getVerification();e instanceof o.Sas?void 0===this._verifier||this._verifier instanceof x?this.setVerifier(new L(e,this,this.outgoingRequestProcessor)):this._verifier instanceof L&&this._verifier.replaceInner(e):e instanceof o.Qr&&void 0===this._verifier&&this.setVerifier(new x(e,this.outgoingRequestProcessor)),this.emit(T.FM.Change)}setVerifier(e){this._verifier&&this.reEmitter.stopReEmitting(this._verifier,[T.FM.Change]),this._verifier=e,this.reEmitter.reEmit(this._verifier,[T.FM.Change])}get transactionId(){return this.inner.flowId}get roomId(){var e;return null==(e=this.inner.roomId)?void 0:e.toString()}get initiatedByMe(){return this.inner.weStarted()}get otherUserId(){return this.inner.otherUserId.toString()}get otherDeviceId(){var e;return null==(e=this.inner.otherDeviceId)?void 0:e.toString()}getOtherDevice(){var e=this;return(0,n.A)(function*(){var r=e.inner.otherDeviceId;if(r)return yield e.olmMachine.getDevice(e.inner.otherUserId,r,5)})()}get isSelfVerification(){return this.inner.isSelfVerification()}get phase(){var e=this.inner.phase();switch(e){case o.VerificationRequestPhase.Created:case o.VerificationRequestPhase.Requested:return T.X9.Requested;case o.VerificationRequestPhase.Ready:return this._accepting?T.X9.Requested:T.X9.Ready;case o.VerificationRequestPhase.Transitioned:if(!this._verifier)throw Error("VerificationRequest: inner phase == Transitioned but no verifier!");return this._verifier.verificationPhase;case o.VerificationRequestPhase.Done:return T.X9.Done;case o.VerificationRequestPhase.Cancelled:return T.X9.Cancelled}throw Error("Unknown verification phase ".concat(e))}get pending(){if(this.inner.isPassive())return!1;var e=this.phase;return e!==T.X9.Done&&e!==T.X9.Cancelled}get accepting(){return this._accepting}get declining(){return this._cancelling}get timeout(){return this.inner.timeRemainingMillis()}get methods(){throw Error("not implemented")}get chosenMethod(){if(this.phase!==T.X9.Started)return null;var e=this.inner.getVerification();return e instanceof o.Sas?U.Sas:e instanceof o.Qr?U.Reciprocate:null}otherPartySupportsMethod(e){var r=this.inner.theirSupportedMethods;if(void 0===r)return!1;var t=F[e];return r.some(e=>e===t)}accept(){var e=this;return(0,n.A)(function*(){if(e.inner.phase()!==o.VerificationRequestPhase.Requested||e._accepting)throw Error("Cannot accept a verification request in phase ".concat(e.phase));e._accepting=!0;try{var r=e.inner.acceptWithMethods(e.supportedVerificationMethods.map(j));r&&(yield e.outgoingRequestProcessor.makeOutgoingRequest(r))}finally{e._accepting=!1}e.emit(T.FM.Change)})()}cancel(e){var r=this;return(0,n.A)(function*(){if(!r._cancelling){r.logger.info("Cancelling verification request with params:",e),r._cancelling=!0;try{var t=r.inner.cancel();t&&(yield r.outgoingRequestProcessor.makeOutgoingRequest(t))}finally{r._cancelling=!1}}})()}beginKeyVerification(e,r){throw Error("not implemented")}startVerification(e){var r=this;return(0,n.A)(function*(){if(e!==U.Sas)throw Error("Unsupported verification method ".concat(e));if(!(yield r.getOtherDevice()))throw Error("startVerification(): other device is unknown");var t=yield r.inner.startSas();if(t){var[,i]=t;yield r.outgoingRequestProcessor.makeOutgoingRequest(i)}if(!r._verifier)throw Error("Still no verifier after startSas() call");return r._verifier})()}scanQRCode(e){var r=this;return(0,n.A)(function*(){var t=o.QrCodeScan.fromBytes(e),i=yield r.inner.scanQrCode(t);if(!r._verifier)throw Error("Still no verifier after scanQrCode() call");var n=i.reciprocate();return n&&(yield r.outgoingRequestProcessor.makeOutgoingRequest(n)),r._verifier})()}get verifier(){return this.phase===T.X9.Started?this._verifier:void 0}getQRCodeBytes(){throw Error("getQRCodeBytes() unsupported in Rust Crypto; use generateQRCode() instead.")}generateQRCode(){var e=this;return(0,n.A)(function*(){if(!(yield e.getOtherDevice()))throw Error("generateQRCode(): other device is unknown");var r=yield e.inner.generateQrCode();if(r)return r.toBytes()})()}get cancellationCode(){var e,r;return null!=(e=null==(r=this.inner.cancelInfo)?void 0:r.cancelCode())?e:null}get cancellingUserId(){var e=this.inner.cancelInfo;return e?e.cancelledbyUs()?this.olmMachine.userId.toString():this.inner.otherUserId.toString():void 0}}class N extends R.X{constructor(e,r){super(),this.inner=e,this.outgoingRequestProcessor=r,(0,i.A)(this,"completionDeferred",void 0),this.completionDeferred=Promise.withResolvers();var t=new WeakRef(this);e.registerChangesCallback((0,n.A)(function*(){var e;return null==(e=t.deref())?void 0:e.onChange()})),this.completionDeferred.promise.catch(()=>null)}onChange(){if(this.inner.isDone())this.completionDeferred.resolve(void 0);else if(this.inner.isCancelled()){var e=this.inner.cancelInfo();this.completionDeferred.reject(Error("Verification cancelled by ".concat(e.cancelledbyUs()?"us":"them"," with code ").concat(e.cancelCode(),": ").concat(e.reason())))}this.emit(T.FM.Change)}get hasBeenCancelled(){return this.inner.isCancelled()}get userId(){return this.inner.otherUserId.toString()}cancel(e){var r=this.inner.cancel();r&&this.outgoingRequestProcessor.makeOutgoingRequest(r)}getShowSasCallbacks(){return null}getReciprocateQrCodeCallbacks(){return null}}class x extends N{constructor(e,r){super(e,r),(0,i.A)(this,"callbacks",null)}onChange(){null===this.callbacks&&this.inner.hasBeenScanned()&&(this.callbacks={confirm:()=>{this.confirmScanning()},cancel:()=>this.cancel()}),super.onChange()}verify(){var e=this;return(0,n.A)(function*(){null!==e.callbacks&&e.emit(T.Ji.ShowReciprocateQr,e.callbacks),yield e.completionDeferred.promise})()}get verificationPhase(){switch(this.inner.state()){case o.QrState.Created:return T.X9.Ready;case o.QrState.Scanned:case o.QrState.Confirmed:case o.QrState.Reciprocated:return T.X9.Started;case o.QrState.Done:return T.X9.Done;case o.QrState.Cancelled:return T.X9.Cancelled;default:throw Error("Unknown qr code state ".concat(this.inner.state()))}}getReciprocateQrCodeCallbacks(){return this.callbacks}confirmScanning(){var e=this;return(0,n.A)(function*(){var r=e.inner.confirmScanning();r&&(yield e.outgoingRequestProcessor.makeOutgoingRequest(r))})()}}class L extends N{constructor(e,r,t){super(e,t),(0,i.A)(this,"callbacks",null)}verify(){var e=this;return(0,n.A)(function*(){yield e.sendAccept(),yield e.completionDeferred.promise})()}sendAccept(){var e=this;return(0,n.A)(function*(){var r=e.inner.accept();r&&(yield e.outgoingRequestProcessor.makeOutgoingRequest(r))})()}onChange(){var e=this;if(super.onChange(),null===this.callbacks){var r,t=this.inner.emoji(),i=this.inner.decimals();if(void 0===t&&void 0===i)return;var o={};t&&(o.emoji=t.map(e=>[e.symbol,e.description])),i&&(o.decimal=[i[0],i[1],i[2]]),this.callbacks={sas:o,confirm:(r=(0,n.A)(function*(){for(var r of yield e.inner.confirm())yield e.outgoingRequestProcessor.makeOutgoingRequest(r)}),function(){return r.apply(this,arguments)}),mismatch:()=>{var e=this.inner.cancelWithCode("m.mismatched_sas");e&&this.outgoingRequestProcessor.makeOutgoingRequest(e)},cancel:()=>{var e=this.inner.cancelWithCode("m.user");e&&this.outgoingRequestProcessor.makeOutgoingRequest(e)}},this.emit(T.Ji.ShowSas,this.callbacks)}}get verificationPhase(){return T.X9.Started}getShowSasCallbacks(){return this.callbacks}replaceInner(e){if(this.inner!=e){this.inner=e;var r=new WeakRef(this);e.registerChangesCallback((0,n.A)(function*(){var e;return null==(e=r.deref())?void 0:e.onChange()})),this.sendAccept(),this.onChange()}}}var F={[U.Sas]:o.VerificationMethod.SasV1,[U.ScanQrCode]:o.VerificationMethod.QrCodeScanV1,[U.ShowQrCode]:o.VerificationMethod.QrCodeShowV1,[U.Reciprocate]:o.VerificationMethod.ReciprocateV1};function j(e){var r=F[e];if(void 0===r)throw Error("Unknown verification method ".concat(e));return r}class G extends R.X{constructor(e,r,t,n){super(),this.logger=e,this.olmMachine=r,this.http=t,this.outgoingRequestProcessor=n,(0,i.A)(this,"checkedForBackup",!1),(0,i.A)(this,"serverBackupInfo",void 0),(0,i.A)(this,"activeBackupVersion",null),(0,i.A)(this,"stopped",!1),(0,i.A)(this,"backupKeysLoopRunning",!1),(0,i.A)(this,"keyBackupCheckInProgress",null)}stop(){this.stopped=!0}getActiveBackupVersion(){var e=this;return(0,n.A)(function*(){return(yield e.olmMachine.isBackupEnabled())?e.activeBackupVersion:null})()}getServerBackupInfo(){var e=this;return(0,n.A)(function*(){return yield e.checkKeyBackupAndEnable(!1),e.serverBackupInfo})()}isKeyBackupTrusted(e){var r=this;return(0,n.A)(function*(){var t=yield r.olmMachine.verifyBackup(e),i=yield r.olmMachine.getBackupKeys(),n=null==i?void 0:i.decryptionKey;return{matchesDecryptionKey:!!n&&r.backupInfoMatchesBackupDecryptionKey(e,n),trusted:t.trusted()}})()}checkKeyBackupAndEnable(e){return!e&&this.checkedForBackup?Promise.resolve(null):(this.keyBackupCheckInProgress||(this.keyBackupCheckInProgress=this.doCheckKeyBackup().finally(()=>{this.keyBackupCheckInProgress=null})),this.keyBackupCheckInProgress)}handleBackupSecretReceived(e){var r=this;return(0,n.A)(function*(){try{i=yield r.requestKeyBackupVersion()}catch(e){return r.logger.warn("handleBackupSecretReceived: Error checking for latest key backup",e),!1}if(!(null!=(t=i)&&t.version))return r.logger.warn("handleBackupSecretReceived: Received a backup decryption key, but there is no trusted server-side key backup"),!1;try{var t,i,n=o.BackupDecryptionKey.fromBase64(e);if(!r.backupInfoMatchesBackupDecryptionKey(i,n))return r.logger.warn("handleBackupSecretReceived: Private decryption key does not match the public key of the current remote backup."),!1;return r.logger.info("handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache."),yield r.saveBackupDecryptionKey(n,i.version),!0}catch(e){r.logger.warn("handleBackupSecretReceived: Invalid backup decryption key",e)}return!1})()}saveBackupDecryptionKey(e,r){var t=this;return(0,n.A)(function*(){yield t.olmMachine.saveBackupDecryptionKey(e,r),t.emit(k.cr.KeyBackupDecryptionKeyCached,r)})()}importRoomKeys(e,r){var t=this;return(0,n.A)(function*(){yield t.importRoomKeysAsJson(JSON.stringify(e),r)})()}importRoomKeysAsJson(e,r){var t=this;return(0,n.A)(function*(){yield t.olmMachine.importExportedRoomKeys(e,(e,t)=>{var i,n={total:Number(t),successes:Number(e),stage:k.wF.LoadKeys,failures:0};null==r||null==(i=r.progressCallback)||i.call(r,n)})})()}importBackedUpRoomKeys(e,r,t){var i=this;return(0,n.A)(function*(){var n=new Map;for(var s of e){var a=new o.RoomId(s.room_id);n.has(a)||n.set(a,new Map),n.get(a).set(s.session_id,s)}yield i.olmMachine.importBackedUpRoomKeys(n,(e,r,i)=>{var n,o={total:Number(r),successes:Number(e),stage:k.wF.LoadKeys,failures:Number(i)};null==t||null==(n=t.progressCallback)||n.call(t,o)},r)})()}doCheckKeyBackup(){var e=this;return(0,n.A)(function*(){e.logger.debug("Checking key backup status...");try{r=yield e.requestKeyBackupVersion()}catch(r){return e.logger.warn("Error checking for active key backup",r),e.serverBackupInfo=void 0,null}e.checkedForBackup=!0,r&&!r.version&&(e.logger.warn("active backup lacks a useful 'version'; ignoring it"),r=void 0),e.serverBackupInfo=r;var r,t=yield e.getActiveBackupVersion();if(!r)return null!==t?(e.logger.debug("No key backup present on server: disabling key backup"),yield e.disableKeyBackup()):e.logger.debug("No key backup present on server: not enabling key backup"),null;var i=yield e.isKeyBackupTrusted(r);return i.matchesDecryptionKey||i.trusted?null===t?(e.logger.debug("Found usable key backup v".concat(r.version,": enabling key backups")),yield e.enableKeyBackup(r)):t!==r.version?(e.logger.debug("On backup version ".concat(t," but found version ").concat(r.version,": switching.")),yield e.disableKeyBackup(),yield e.enableKeyBackup(r)):e.logger.debug("Backup version ".concat(r.version," still current")):null!==t?(e.logger.debug("Key backup present on server but not trusted: disabling key backup"),yield e.disableKeyBackup()):e.logger.debug("Key backup present on server but not trusted: not enabling key backup"),{backupInfo:r,trustInfo:i}})()}enableKeyBackup(e){var r=this;return(0,n.A)(function*(){yield r.olmMachine.enableBackupV1(e.auth_data.public_key,e.version),r.activeBackupVersion=e.version,r.emit(k.cr.KeyBackupStatus,!0),r.backupKeysLoop()})()}maybeUploadKey(){var e=this;return(0,n.A)(function*(){null!=e.activeBackupVersion&&e.backupKeysLoop()})()}disableKeyBackup(){var e=this;return(0,n.A)(function*(){yield e.olmMachine.disableBackup(),e.activeBackupVersion=null,e.emit(k.cr.KeyBackupStatus,!1)})()}backupKeysLoop(){var e=arguments,r=this;return(0,n.A)(function*(){var t=e.length>0&&void 0!==e[0]?e[0]:1e4;if(r.backupKeysLoopRunning)return void r.logger.debug("Backup loop already running");r.backupKeysLoopRunning=!0,r.logger.debug("Backup: Starting keys upload loop for backup version:".concat(r.activeBackupVersion,"."));var i=Math.random()*t;yield(0,m.yy)(i);try{for(var o=0,s=null,a=!0;!r.stopped;){var c=void 0;try{c=yield(0,m.NQ)(r.logger,"BackupRoomKeys: Get keys to backup from rust crypto-sdk",(0,n.A)(function*(){return yield r.olmMachine.backupRoomKeys()}))}catch(e){r.logger.error("Backup: Failed to get keys to backup from rust crypto-sdk",e)}if(!c||r.stopped||!r.activeBackupVersion){r.logger.debug("Backup: Ending loop for version ".concat(r.activeBackupVersion,".")),c||r.emit(k.cr.KeyBackupSessionsRemaining,0);return}try{if(yield r.outgoingRequestProcessor.makeOutgoingRequest(c),o=0,r.stopped)break;if(!a&&null===s)try{var u=yield r.olmMachine.roomKeyCounts();s=u.total-u.backedUp}catch(e){r.logger.error("Backup: Failed to get key counts from rust crypto-sdk",e)}if(null!==s){r.emit(k.cr.KeyBackupSessionsRemaining,s);var d=r.keysCountInBatch(c);s=Math.max(s-d,0)}}catch(e){if(o++,r.logger.error("Backup: Error processing backup request for rust crypto-sdk",e),e instanceof p.up){var l=e.data.errcode;if("M_NOT_FOUND"==l||"M_WRONG_ROOM_KEYS_VERSION"==l){r.logger.debug("Backup: Failed to upload keys to current vesion: ".concat(l,"."));try{yield r.disableKeyBackup()}catch(e){r.logger.error("Backup: An error occurred while disabling key backup:",e)}r.emit(k.cr.KeyBackupFailed,e.data.errcode),r.backupKeysLoopRunning=!1,r.checkKeyBackupAndEnable(!0);return}if(e.isRateLimitError())try{var g=e.getRetryAfterMs();if(g&&g>0){yield(0,m.yy)(g);continue}}catch(e){r.logger.warn("Backup: An error occurred while retrieving a rate-limit retry delay",e)}}yield(0,m.yy)(1e3*Math.pow(2,Math.min(o-1,4)))}a=!1}}finally{r.backupKeysLoopRunning=!1}})()}keysCountInBatch(e){return Y(JSON.parse(e.body))}requestKeyBackupVersion(e){var r=this;return(0,n.A)(function*(){return yield J(r.http,e)})()}setupKeyBackup(e){var r=this;return(0,n.A)(function*(){yield r.deleteAllKeyBackupVersions();var t=o.BackupDecryptionKey.createRandomKey(),i=t.megolmV1PublicKey,n={public_key:i.publicKeyBase64};yield e(n);var s=yield r.http.authedRequest(p.IT.Post,"/room_keys/version",void 0,{algorithm:i.algorithm,auth_data:n},{prefix:p.iD.V3});return yield r.saveBackupDecryptionKey(t,s.version),{version:s.version,algorithm:i.algorithm,authData:n,decryptionKey:t}})()}deleteAllKeyBackupVersions(){var e=this;return(0,n.A)(function*(){for(var r,t,i,n,o=null!=(r=null==(t=yield e.requestKeyBackupVersion())?void 0:t.version)?r:null;null!=o;)yield e.deleteKeyBackupVersion(o),o=null!=(i=null==(n=yield e.requestKeyBackupVersion())?void 0:n.version)?i:null})()}deleteKeyBackupVersion(e){var r=this;return(0,n.A)(function*(){r.logger.debug("deleteKeyBackupVersion v:".concat(e));var t=(0,m.RR)("/room_keys/version/$version",{$version:e});yield r.http.authedRequest(p.IT.Delete,t,void 0,void 0,{prefix:p.iD.V3}),r.activeBackupVersion===e&&(r.serverBackupInfo=null,yield r.disableKeyBackup())})()}createBackupDecryptor(e){return new W(this.logger,e)}restoreKeyBackup(e,r,t){var i=this;return(0,n.A)(function*(){var n=yield i.downloadKeyBackup(e);return i.importKeyBackup(n,e,r,t)})()}downloadKeyBackup(e){return this.http.authedRequest(p.IT.Get,"/room_keys/keys",{version:e},void 0,{prefix:p.iD.V3})}importKeyBackup(e,r,t,i){var o=this;return(0,n.A)(function*(){var s,a,c=Y(e),u=0,d=0;null==i||null==(s=i.progressCallback)||s.call(i,{total:c,successes:u,stage:k.wF.LoadKeys,failures:d});var l=(a=(0,n.A)(function*(e){var n,s=[],a=function*(r){(yield t.decryptSessions(e.get(r))).forEach(e=>{e.room_id=r,s.push(e)})};for(var l of e.keys())yield*a(l);try{yield o.importBackedUpRoomKeys(s,r),u+=s.length}catch(e){d+=s.length,o.logger.error("Error importing keys from backup",e)}null==i||null==(n=i.progressCallback)||n.call(i,{total:c,successes:u,stage:k.wF.LoadKeys,failures:d})}),function(e){return a.apply(this,arguments)}),g=0,y=new Map;for(var[h,p]of Object.entries(e.rooms))if(p.sessions)for(var[v,f]of(y.set(h,{}),Object.entries(p.sessions)))y.get(h)[v]=f,(g+=1)>=200&&(yield l(y),(y=new Map).set(h,{}),g=0);return g>0&&(yield l(y)),{total:c,imported:u}})()}backupInfoMatchesBackupDecryptionKey(e,r){var t;return"m.megolm_backup.v1.curve25519-aes-sha2"!==e.algorithm?(this.logger.warn("backupMatchesPrivateKey: Unsupported backup algorithm",e.algorithm),!1):(null==(t=e.auth_data)?void 0:t.public_key)===r.megolmV1PublicKey.publicKeyBase64}}class W{constructor(e,r){this.logger=e,(0,i.A)(this,"decryptionKey",void 0),(0,i.A)(this,"sourceTrusted",void 0),this.decryptionKey=r,this.sourceTrusted=!1}decryptSessions(e){var r=this;return(0,n.A)(function*(){var t=[];for(var[i,n]of Object.entries(e))try{var o=JSON.parse(r.decryptionKey.decryptV1(n.session_data.ephemeral,n.session_data.mac,n.session_data.ciphertext));o.session_id=i,t.push(o)}catch(e){r.logger.debug("Failed to decrypt megolm session from backup",e,n)}return t})()}free(){this.decryptionKey.free()}}function J(e,r){return Q.apply(this,arguments)}function Q(){return(Q=(0,n.A)(function*(e,r){try{var t=r?(0,m.RR)("/room_keys/version/$version",{$version:r}):"/room_keys/version";return yield e.authedRequest(p.IT.Get,t,void 0,void 0,{prefix:p.iD.V3})}catch(e){if("M_NOT_FOUND"===e.errcode)return null;throw e}})).apply(this,arguments)}function H(e,r){return r.auth_data.public_key===e.megolmV1PublicKey.publicKeyBase64}function Y(e){var r=0;for(var{sessions:t}of Object.values(e.rooms))r+=Object.keys(t).length;return r}var X=t(5862),z=t(69103);class ${constructor(e,r,t){this.logger=e,this.olmMachine=r,this.outgoingRequestProcessor=t,(0,i.A)(this,"stopped",!1),(0,i.A)(this,"outgoingRequestLoopRunning",!1),(0,i.A)(this,"nextLoopDeferred",void 0)}stop(){this.stopped=!0}doProcessOutgoingRequests(){this.nextLoopDeferred||(this.nextLoopDeferred=Promise.withResolvers());var e=this.nextLoopDeferred.promise;return this.outgoingRequestLoopRunning||this.outgoingRequestLoop().catch(e=>{this.logger.error("Uncaught error in outgoing request loop",e)}),e}outgoingRequestLoop(){var e=this;return(0,n.A)(function*(){if(e.outgoingRequestLoopRunning)throw Error("Cannot run two outgoing request loops");e.outgoingRequestLoopRunning=!0;try{for(;!e.stopped&&e.nextLoopDeferred;){var r=e.nextLoopDeferred;e.nextLoopDeferred=void 0,yield e.processOutgoingRequests().then(r.resolve,r.reject)}}finally{e.outgoingRequestLoopRunning=!1}e.nextLoopDeferred&&e.nextLoopDeferred.reject(Error("OutgoingRequestsManager was stopped"))})()}processOutgoingRequests(){var e=this;return(0,n.A)(function*(){if(!e.stopped){var r,t=yield e.olmMachine.outgoingRequests(),i=0,o=function*(r){if(e.stopped)return{v:void 0};try{yield(0,m.NQ)(e.logger,"Make outgoing request ".concat(r.type),(0,n.A)(function*(){yield e.outgoingRequestProcessor.makeOutgoingRequest(r),i++}))}catch(t){e.logger.error("Failed to process outgoing request ".concat(r.type,": ").concat(t))}};for(var s of t)if(r=yield*o(s))return r.v;i>0&&e.doProcessOutgoingRequests().catch(r=>{e.logger.warn("processOutgoingRequests: Error re-checking outgoing requests",r)})}})()}}var Z=function(e){return e.MISSING_DECRYPTION_KEY="MISSING_DECRYPTION_KEY",e.NETWORK_ERROR="NETWORK_ERROR",e.STOPPED="STOPPED",e}(Z||{});class ee extends Error{constructor(e){super("Failed to get key from backup: ".concat(e)),this.code=e,this.name="KeyDownloadError"}}class er extends Error{constructor(e){super("Failed to get key from backup: rate limited"),this.retryMillis=e,this.name="KeyDownloadRateLimitError"}}class et{constructor(e,r,t,n){this.olmMachine=r,this.http=t,this.backupManager=n,(0,i.A)(this,"stopped",!1),(0,i.A)(this,"configuration",null),(0,i.A)(this,"sessionLastCheckAttemptedTime",new Map),(0,i.A)(this,"logger",void 0),(0,i.A)(this,"downloadLoopRunning",!1),(0,i.A)(this,"queuedRequests",[]),(0,i.A)(this,"hasConfigurationProblem",!1),(0,i.A)(this,"currentBackupVersionCheck",null),(0,i.A)(this,"onBackupStatusChanged",()=>{this.hasConfigurationProblem=!1,this.configuration=null,this.getOrCreateBackupConfiguration().then(e=>{e&&this.downloadKeysLoop()})}),this.logger=e.getChild("[PerSessionKeyBackupDownloader]"),n.on(k.cr.KeyBackupStatus,this.onBackupStatusChanged),n.on(k.cr.KeyBackupFailed,this.onBackupStatusChanged),n.on(k.cr.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isKeyBackupDownloadConfigured(){return null!==this.configuration}getServerBackupInfo(){var e=this;return(0,n.A)(function*(){return yield e.backupManager.getServerBackupInfo()})()}onDecryptionKeyMissingError(e,r){return this.isAlreadyInQueue(e,r)?void this.logger.trace("Not checking key backup for session ".concat(r," as it is already queued")):this.wasRequestedRecently(r)?void this.logger.trace("Not checking key backup for session ".concat(r," as it was already requested recently")):void(this.queuedRequests.push({roomId:e,megolmSessionId:r}),this.downloadKeysLoop())}stop(){this.stopped=!0,this.backupManager.off(k.cr.KeyBackupStatus,this.onBackupStatusChanged),this.backupManager.off(k.cr.KeyBackupFailed,this.onBackupStatusChanged),this.backupManager.off(k.cr.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isAlreadyInQueue(e,r){return this.queuedRequests.some(t=>t.roomId==e&&t.megolmSessionId==r)}markAsNotFoundInBackup(e){var r=Date.now();this.sessionLastCheckAttemptedTime.set(e,r),this.sessionLastCheckAttemptedTime.size>100&&(this.sessionLastCheckAttemptedTime=new Map(Array.from(this.sessionLastCheckAttemptedTime).filter((e,t)=>5e3>Math.max(r-t,0))))}wasRequestedRecently(e){var r=this.sessionLastCheckAttemptedTime.get(e);return!!r&&5e3>Math.max(Date.now()-r,0)}getBackupDecryptionKey(){var e=this;return(0,n.A)(function*(){try{return yield e.olmMachine.getBackupKeys()}catch(e){return null}})()}requestRoomKeyFromBackup(e,r,t){var i=this;return(0,n.A)(function*(){var n=(0,m.RR)("/room_keys/keys/$roomId/$sessionId",{$roomId:r,$sessionId:t});return yield i.http.authedRequest(p.IT.Get,n,{version:e},void 0,{prefix:p.iD.V3})})()}downloadKeysLoop(){var e=this;return(0,n.A)(function*(){if(!e.downloadLoopRunning&&!e.hasConfigurationProblem){e.downloadLoopRunning=!0;try{for(;e.queuedRequests.length>0;){var r=e.queuedRequests[0];try{var t=yield e.getOrCreateBackupConfiguration();if(!t){e.downloadLoopRunning=!1;return}var i=yield e.queryKeyBackup(r.roomId,r.megolmSessionId,t);if(e.stopped)return;try{yield e.decryptAndImport(r,i,t)}catch(t){e.logger.error("Error while decrypting and importing key backup for session ".concat(r.megolmSessionId),t)}e.queuedRequests.shift()}catch(t){if(t instanceof ee)switch(t.code){case Z.MISSING_DECRYPTION_KEY:e.markAsNotFoundInBackup(r.megolmSessionId),e.queuedRequests.shift();break;case Z.NETWORK_ERROR:yield(0,m.yy)(5e3);break;case Z.STOPPED:e.downloadLoopRunning=!1;return}else t instanceof er&&(yield(0,m.yy)(t.retryMillis))}}}finally{e.downloadLoopRunning=!1}}})()}queryKeyBackup(e,r,t){var i=this;return(0,n.A)(function*(){if(i.logger.debug("Checking key backup for session ".concat(r)),i.stopped)throw new ee(Z.STOPPED);try{var n,o,s=yield i.requestRoomKeyFromBackup(t.backupVersion,e,r);return i.logger.debug("Got key from backup for sessionId:".concat(r)),s}catch(e){if(i.stopped)throw new ee(Z.STOPPED);if(i.logger.info("No luck requesting key backup for session ".concat(r,": ").concat(e)),e instanceof p.up){if("M_NOT_FOUND"==e.data.errcode)throw new ee(Z.MISSING_DECRYPTION_KEY);if(e.isRateLimitError()){try{n=null!=(o=e.getRetryAfterMs())?o:void 0}catch(e){i.logger.warn("Error while retrieving a rate-limit retry delay",e)}throw n&&n>0&&i.logger.info("Rate limited by server, waiting ".concat(n,"ms")),new er(null!=n?n:5e3)}}throw new ee(Z.NETWORK_ERROR)}})()}decryptAndImport(e,r,t){var i=this;return(0,n.A)(function*(){var n={[e.megolmSessionId]:r},o=yield t.decryptor.decryptSessions(n);for(var s of o)s.room_id=e.roomId;yield i.backupManager.importBackedUpRoomKeys(o,t.backupVersion)})()}getOrCreateBackupConfiguration(){var e=this;return(0,n.A)(function*(){if(e.configuration)return e.configuration;if(e.hasConfigurationProblem)return null;if(null!=e.currentBackupVersionCheck)return e.logger.debug("Already checking server version, use current promise"),yield e.currentBackupVersionCheck;e.currentBackupVersionCheck=e.internalCheckFromServer();try{return yield e.currentBackupVersionCheck}finally{e.currentBackupVersionCheck=null}})()}internalCheckFromServer(){var e=this;return(0,n.A)(function*(){var r,t,i,n,o=null;try{o=yield e.backupManager.getServerBackupInfo()}catch(r){return e.logger.debug("Backup: error while checking server version: ".concat(r)),e.hasConfigurationProblem=!0,null}if(e.logger.debug("Got current backup version from server: ".concat(null==(r=o)?void 0:r.version)),(null==(t=o)?void 0:t.algorithm)!="m.megolm_backup.v1.curve25519-aes-sha2")return e.logger.info("Unsupported algorithm ".concat(null==(n=o)?void 0:n.algorithm)),e.hasConfigurationProblem=!0,null;if(!(null!=(i=o)&&i.version))return e.logger.info("No current key backup"),e.hasConfigurationProblem=!0,null;var s=yield e.backupManager.getActiveBackupVersion();if(null==s||o.version!=s)return e.logger.info("The current backup version on the server (".concat(o.version,") is not trusted. Version we are currently backing up to: ").concat(s)),e.hasConfigurationProblem=!0,null;var a=yield e.getBackupDecryptionKey();if(!(null!=a&&a.decryptionKey))return e.logger.debug("Not checking key backup for session (no decryption key)"),e.hasConfigurationProblem=!0,null;if(s!=a.backupVersion)return e.logger.debug("Version for which we have a decryption key (".concat(a.backupVersion,") doesn't match the version we are backing up to (").concat(s,")")),e.hasConfigurationProblem=!0,null;if(o.auth_data.public_key!=a.decryptionKey.megolmV1PublicKey.publicKeyBase64)return e.logger.debug("Key backup on server does not match our decryption key"),e.hasConfigurationProblem=!0,null;var c=e.backupManager.createBackupDecryptor(a.decryptionKey);return e.hasConfigurationProblem=!1,e.configuration={decryptor:c,backupVersion:s},e.configuration})()}}var ei=t(83656);function en(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);r&&(i=i.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,i)}return t}function eo(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?en(Object(t),!0).forEach(function(r){(0,i.A)(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):en(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}var es=[U.Sas,U.ScanQrCode,U.ShowQrCode,U.Reciprocate];class ea extends R.X{constructor(e,r,t,n,o,s,a){var c=arguments.length>7&&void 0!==arguments[7]&&arguments[7];super(),this.logger=e,this.olmMachine=r,this.http=t,this.userId=n,this.secretStorage=s,this.cryptoCallbacks=a,this.enableEncryptedStateEvents=c,(0,i.A)(this,"RECOVERY_KEY_DERIVATION_ITERATIONS",5e5),(0,i.A)(this,"_trustCrossSignedDevices",!0),(0,i.A)(this,"deviceIsolationMode",new k.ux(!1)),(0,i.A)(this,"stopped",!1),(0,i.A)(this,"roomEncryptors",{}),(0,i.A)(this,"roomsPendingKeyBundles",new Map),(0,i.A)(this,"eventDecryptor",void 0),(0,i.A)(this,"keyClaimManager",void 0),(0,i.A)(this,"outgoingRequestProcessor",void 0),(0,i.A)(this,"crossSigningIdentity",void 0),(0,i.A)(this,"backupManager",void 0),(0,i.A)(this,"outgoingRequestsManager",void 0),(0,i.A)(this,"perSessionBackupDownloader",void 0),(0,i.A)(this,"dehydratedDeviceManager",void 0),(0,i.A)(this,"reemitter",new P.Q(this)),(0,i.A)(this,"globalBlacklistUnverifiedDevices",!1),(0,i.A)(this,"_supportedVerificationMethods",es),this.outgoingRequestProcessor=new M(e,r,t),this.outgoingRequestsManager=new $(this.logger,r,this.outgoingRequestProcessor),this.keyClaimManager=new A(r,this.outgoingRequestProcessor),this.backupManager=new G(e,r,t,this.outgoingRequestProcessor),this.perSessionBackupDownloader=new et(this.logger,this.olmMachine,this.http,this.backupManager),this.dehydratedDeviceManager=new K(this.logger,r,t,this.outgoingRequestProcessor,s),this.eventDecryptor=new ec(this.logger,r,this.perSessionBackupDownloader),this.reemitter.reEmit(this.backupManager,[k.cr.KeyBackupStatus,k.cr.KeyBackupSessionsRemaining,k.cr.KeyBackupFailed,k.cr.KeyBackupDecryptionKeyCached]),this.reemitter.reEmit(this.dehydratedDeviceManager,[k.cr.DehydratedDeviceCreated,k.cr.DehydratedDeviceUploaded,k.cr.RehydrationStarted,k.cr.RehydrationProgress,k.cr.RehydrationCompleted,k.cr.RehydrationError,k.cr.DehydrationKeyCached,k.cr.DehydratedDeviceRotationError]),this.crossSigningIdentity=new D(e,r,this.outgoingRequestProcessor,s),this.checkKeyBackupAndEnable()}getOlmMachineOrThrow(){if(this.stopped)throw new z.LA;return this.olmMachine}set globalErrorOnUnknownDevices(e){}get globalErrorOnUnknownDevices(){return!1}stop(){this.stopped||(this.stopped=!0,this.keyClaimManager.stop(),this.backupManager.stop(),this.outgoingRequestsManager.stop(),this.perSessionBackupDownloader.stop(),this.dehydratedDeviceManager.stop(),this.olmMachine.close())}encryptEvent(e,r){var t=this;return(0,n.A)(function*(){var r=e.getRoomId(),i=t.roomEncryptors[r];if(!i)throw Error("Cannot encrypt event in unconfigured room ".concat(r));yield i.encryptEvent(e,t.globalBlacklistUnverifiedDevices,t.deviceIsolationMode)})()}decryptEvent(e){var r=this;return(0,n.A)(function*(){if(!e.getRoomId())throw Error("to-device event was not decrypted in preprocessToDeviceMessages");return yield r.eventDecryptor.attemptEventDecryption(e,r.deviceIsolationMode)})()}getBackupDecryptor(e,r){var t=this;return(0,n.A)(function*(){if(!(r instanceof Uint8Array))throw Error("getBackupDecryptor: expects Uint8Array");if("m.megolm_backup.v1.curve25519-aes-sha2"!=e.algorithm)throw Error("getBackupDecryptor: Unsupported algorithm ".concat(e.algorithm));var i=o.BackupDecryptionKey.fromBase64((0,b.WG)(r));if(!H(i,e))throw Error("getBackupDecryptor: key backup on server does not match the decryption key");return t.backupManager.createBackupDecryptor(i)})()}importBackedUpRoomKeys(e,r,t){var i=this;return(0,n.A)(function*(){return yield i.backupManager.importBackedUpRoomKeys(e,r,t)})()}maybeAcceptKeyBundle(e,r){var t=this;return(0,n.A)(function*(){var i,n=new h.Tl(t.logger,"maybeAcceptKeyBundle(".concat(e,", ").concat(r,")"));n.info("Checking inviter cross-signing keys");var s=t.olmMachine.queryKeysForUsers([new o.UserId(r)]);yield t.outgoingRequestProcessor.makeOutgoingRequest(s);var a=yield t.olmMachine.getReceivedRoomKeyBundleData(new o.RoomId(e),new o.UserId(r));if(!a)return n.info("No key bundle found for user"),!1;n.info("Fetching key bundle ".concat(a.url));var c=(0,ei.y)(t.http.opts.baseUrl,a.url,void 0,void 0,void 0,!1,!0,!0);try{var u=new URL(c);i=yield t.http.authedRequest(p.IT.Get,u.pathname+u.search,{},void 0,{rawResponseBody:!0,prefix:""})}catch(e){throw n.warn("Error downloading encrypted bundle from ".concat(c,":"),e),e}n.info("Received blob of length ".concat(i.size));try{yield t.olmMachine.receiveRoomKeyBundle(a,new Uint8Array((yield i.arrayBuffer())))}catch(e){throw n.warn("Error receiving encrypted bundle:",e),e}return!0})()}markRoomAsPendingKeyBundle(e,r){this.roomsPendingKeyBundles.set(e,r)}getVersion(){var e=o.getVersions();return"Rust SDK ".concat(e.matrix_sdk_crypto," (").concat(e.git_sha,"), Vodozemac ").concat(e.vodozemac)}setDeviceIsolationMode(e){this.deviceIsolationMode=e}isEncryptionEnabledInRoom(e){var r=this;return(0,n.A)(function*(){var t=yield r.olmMachine.getRoomSettings(new o.RoomId(e));return!!(null==t?void 0:t.algorithm)})()}isStateEncryptionEnabledInRoom(e){var r=this;return(0,n.A)(function*(){var t=yield r.olmMachine.getRoomSettings(new o.RoomId(e));return!!(null==t?void 0:t.encryptStateEvents)})()}getOwnDeviceKeys(){var e=this;return(0,n.A)(function*(){var r=e.olmMachine.identityKeys;return{ed25519:r.ed25519.toBase64(),curve25519:r.curve25519.toBase64()}})()}prepareToEncrypt(e){var r=this.roomEncryptors[e.roomId];r&&r.prepareForEncryption(this.globalBlacklistUnverifiedDevices,this.deviceIsolationMode)}forceDiscardSession(e){var r;return null==(r=this.roomEncryptors[e])?void 0:r.forceDiscardSession()}exportRoomKeys(){var e=this;return(0,n.A)(function*(){return JSON.parse((yield e.olmMachine.exportRoomKeys(()=>!0)))})()}exportRoomKeysAsJson(){var e=this;return(0,n.A)(function*(){return yield e.olmMachine.exportRoomKeys(()=>!0)})()}importRoomKeys(e,r){var t=this;return(0,n.A)(function*(){return yield t.backupManager.importRoomKeys(e,r)})()}importRoomKeysAsJson(e,r){var t=this;return(0,n.A)(function*(){return yield t.backupManager.importRoomKeysAsJson(e,r)})()}userHasCrossSigningKeys(){var e=arguments,r=this;return(0,n.A)(function*(){var t=e.length>0&&void 0!==e[0]?e[0]:r.userId,i=e.length>1&&void 0!==e[1]&&e[1];for(var n of yield r.olmMachine.trackedUsers())if(t===n.toString()){a=n;break}if(void 0!==a){if(t===r.userId){var o=r.olmMachine.queryKeysForUsers([a.clone()]);yield r.outgoingRequestProcessor.makeOutgoingRequest(o)}var s=yield r.olmMachine.getIdentity(a);return null==s||s.free(),void 0!==s}if(!i)return!1;var a,c,u=null==(c=(yield r.downloadDeviceList(new Set([t]))).master_keys)?void 0:c[t];return!!u&&!!Object.values(u.keys)[0]})()}getUserDeviceInfo(e){var r=arguments,t=this;return(0,n.A)(function*(){var i=r.length>1&&void 0!==r[1]&&r[1],n=new Map,o=yield t.getOlmMachineOrThrow().trackedUsers(),s=new Set;o.forEach(e=>s.add(e.toString()));var a=new Set;for(var c of e)s.has(c)?n.set(c,(yield t.getUserDevices(c))):a.add(c);return i&&a.size>=1&&Object.entries((yield t.downloadDeviceList(a)).device_keys).forEach(e=>{var[r,t]=e;return n.set(r,new Map(Object.entries(t).map(e=>{var[r,t]=e;return[r,function(e){var r,t=new Map(Object.entries(e.keys)),i=null==(r=e.unsigned)?void 0:r.device_display_name,n=new Map;if(e.signatures)for(var o in e.signatures)n.set(o,new Map(Object.entries(e.signatures[o])));return new _.p({deviceId:e.device_id,userId:e.user_id,keys:t,algorithms:e.algorithms,verified:_.u.Unverified,signatures:n,displayName:i})}(t)]})))}),n})()}getUserDevices(e){var r=this;return(0,n.A)(function*(){var t=new o.UserId(e),i=yield r.olmMachine.getUserDevices(t,1);try{var n=i.devices();try{return new Map(n.map(e=>[e.deviceId.toString(),function(e,r){var t=new Map;for(var[i,n]of e.keys.entries())t.set(i.toString(),n.toBase64());var s=_.u.Unverified;e.isBlacklisted()?s=_.u.Blocked:e.isVerified()&&(s=_.u.Verified);var a=new Map,c=e.signatures.get(r);if(c){var u=new Map;for(var[d,l]of c.entries())l.isValid()&&l.signature&&u.set(d,l.signature.toBase64());a.set(r.toString(),u)}var g=e.algorithms,y=new Set;return g.forEach(e=>{switch(e){case o.EncryptionAlgorithm.MegolmV1AesSha2:y.add("m.megolm.v1.aes-sha2");break;case o.EncryptionAlgorithm.OlmV1Curve25519AesSha2:default:y.add("m.olm.v1.curve25519-aes-sha2")}}),new _.p({deviceId:e.deviceId.toString(),userId:r.toString(),keys:t,algorithms:Array.from(y),verified:s,signatures:a,displayName:e.displayName,dehydrated:e.isDehydrated})}(e,t)]))}finally{n.forEach(e=>e.free())}}finally{i.free()}})()}downloadDeviceList(e){var r=this;return(0,n.A)(function*(){var t={device_keys:{}};return e.forEach(e=>t.device_keys[e]=[]),yield r.http.authedRequest(p.IT.Post,"/_matrix/client/v3/keys/query",void 0,t,{prefix:""})})()}getTrustCrossSignedDevices(){return this._trustCrossSignedDevices}setTrustCrossSignedDevices(e){this._trustCrossSignedDevices=e}setDeviceVerified(e,r){var t=arguments,i=this;return(0,n.A)(function*(){var n=!(t.length>2)||void 0===t[2]||t[2],s=yield i.olmMachine.getDevice(new o.UserId(e),new o.DeviceId(r));if(!s)throw Error("Unknown device ".concat(e,"|").concat(r));try{yield s.setLocalTrust(n?o.LocalTrust.Verified:o.LocalTrust.Unset)}finally{s.free()}})()}crossSignDevice(e){var r=this;return(0,n.A)(function*(){var t=yield r.olmMachine.getDevice(new o.UserId(r.userId),new o.DeviceId(e));if(!t)throw Error("Unknown device ".concat(e));try{var i=yield t.verify();yield r.outgoingRequestProcessor.makeOutgoingRequest(i)}finally{t.free()}})()}getDeviceVerificationStatus(e,r){var t=this;return(0,n.A)(function*(){var i=yield t.olmMachine.getDevice(new o.UserId(e),new o.DeviceId(r));if(!i)return null;try{return new k.wc({signedByOwner:i.isCrossSignedByOwner(),crossSigningVerified:i.isCrossSigningTrusted(),localVerified:i.isLocallyTrusted(),trustCrossSignedDevices:t._trustCrossSignedDevices})}finally{i.free()}})()}getUserVerificationStatus(e){var r=this;return(0,n.A)(function*(){var t=yield r.getOlmMachineOrThrow().getIdentity(new o.UserId(e));if(void 0===t)return new k.L0(!1,!1,!1);var i=t.isVerified(),n=t.wasPreviouslyVerified(),s=t instanceof o.OtherUserIdentity&&t.identityNeedsUserApproval();return t.free(),new k.L0(i,n,!1,s)})()}pinCurrentUserIdentity(e){var r=this;return(0,n.A)(function*(){var t=yield r.getOlmMachineOrThrow().getIdentity(new o.UserId(e));if(void 0===t)throw Error("Cannot pin identity of unknown user");if(t instanceof o.OwnUserIdentity)throw Error("Cannot pin identity of own user");yield t.pinCurrentMasterKey()})()}withdrawVerificationRequirement(e){var r=this;return(0,n.A)(function*(){var t=yield r.getOlmMachineOrThrow().getIdentity(new o.UserId(e));if(void 0===t)throw Error("Cannot withdraw verification of unknown user");yield t.withdrawVerification()})()}isCrossSigningReady(){var e=this;return(0,n.A)(function*(){var{privateKeysInSecretStorage:r,privateKeysCachedLocally:t}=yield e.getCrossSigningStatus(),i=!!t.masterKey&&!!t.selfSigningKey&&!!t.userSigningKey,n=yield e.getOwnIdentity();return!!(null!=n&&n.isVerified())&&(i||r)})()}getCrossSigningKeyId(){var e=arguments,r=this;return(0,n.A)(function*(){var t=e.length>0&&void 0!==e[0]?e[0]:k.nX.Master,i=yield r.olmMachine.getIdentity(new o.UserId(r.userId));if(!i)return null;try{var n,s=yield r.olmMachine.crossSigningStatus();if(!(s.hasMaster&&s.hasUserSigning&&s.hasSelfSigning)||!i.isVerified())return null;switch(t){case k.nX.Master:n=i.masterKey;break;case k.nX.SelfSigning:n=i.selfSigningKey;break;case k.nX.UserSigning:n=i.userSigningKey;break;default:return null}var a=JSON.parse(n);return Object.values(a.keys)[0]}finally{i.free()}})()}bootstrapCrossSigning(e){var r=this;return(0,n.A)(function*(){yield r.crossSigningIdentity.bootstrapCrossSigning(e)})()}isSecretStorageReady(){var e=this;return(0,n.A)(function*(){return(yield e.getSecretStorageStatus()).ready})()}getSecretStorageStatus(){var e=this;return(0,n.A)(function*(){var r=["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"];(yield e.backupManager.getActiveBackupVersion())!=null&&r.push("m.megolm_backup.v1");var t=yield e.secretStorage.getDefaultKeyId(),i={ready:!0,defaultKeyId:t,secretStorageKeyValidityMap:{}};for(var n of r){var o=(yield e.secretStorage.isStored(n))||{},s=!!t&&t in o;i.secretStorageKeyValidityMap[n]=s,i.ready=i.ready&&s}return i})()}bootstrapSecretStorage(){var e=arguments,r=this;return(0,n.A)(function*(){var{createSecretStorageKey:t,setupNewSecretStorage:i,setupNewKeyBackup:n}=e.length>0&&void 0!==e[0]?e[0]:{},o=i||!(yield r.secretStorageHasAESKey());if(o){if(!t)throw Error("unable to create a new secret storage key, createSecretStorageKey is not set");r.logger.info("bootstrapSecretStorage: creating new secret storage key");var s=yield t();if(!s)throw Error("createSecretStorageKey() callback did not return a secret storage key");yield r.addSecretStorageKeyToSecretStorage(s)}var a=yield r.olmMachine.exportCrossSigningKeys();a&&void 0!==a.masterKey&&void 0!==a.self_signing_key&&void 0!==a.userSigningKey&&(o||!(yield O(r.secretStorage)))&&(r.logger.info("bootstrapSecretStorage: cross-signing keys not yet exported; doing so now."),yield r.secretStorage.store("m.cross_signing.master",a.masterKey),yield r.secretStorage.store("m.cross_signing.user_signing",a.userSigningKey),yield r.secretStorage.store("m.cross_signing.self_signing",a.self_signing_key)),n?yield r.resetKeyBackup():yield r.saveBackupKeyToStorage()})()}saveBackupKeyToStorage(){var e=this;return(0,n.A)(function*(){var r=yield e.backupManager.getServerBackupInfo();if(!r||!r.version)return void e.logger.info("Not saving backup key to secret storage: no backup info");var t=yield e.olmMachine.getBackupKeys();if(!t.decryptionKey)return void e.logger.info("Not saving backup key to secret storage: no backup key");if(!H(t.decryptionKey,r))return void e.logger.info("Not saving backup key to secret storage: decryption key does not match backup info");var i=t.decryptionKey.toBase64();yield e.secretStorage.store("m.megolm_backup.v1",i)})()}addSecretStorageKeyToSecretStorage(e){var r=this;return(0,n.A)(function*(){var t,i,n,o,s=yield r.secretStorage.addKey(C.SECRET_STORAGE_ALGORITHM_V1_AES,{passphrase:null==(t=e.keyInfo)?void 0:t.passphrase,name:null==(i=e.keyInfo)?void 0:i.name,key:e.privateKey});yield r.secretStorage.setDefaultKeyId(s.keyId),null==(n=(o=r.cryptoCallbacks).cacheSecretStorageKey)||n.call(o,s.keyId,s.keyInfo,e.privateKey)})()}secretStorageHasAESKey(){var e=this;return(0,n.A)(function*(){var r=yield e.secretStorage.getKey();if(!r)return!1;var[,t]=r;return t.algorithm===C.SECRET_STORAGE_ALGORITHM_V1_AES})()}getCrossSigningStatus(){var e=this;return(0,n.A)(function*(){var r=yield e.getOlmMachineOrThrow().getIdentity(new o.UserId(e.userId)),t=!!(null==r?void 0:r.masterKey)&&!!(null==r?void 0:r.selfSigningKey)&&!!(null==r?void 0:r.userSigningKey);null==r||r.free();var i=yield O(e.secretStorage),n=yield e.getOlmMachineOrThrow().crossSigningStatus();return{publicKeysOnDevice:t,privateKeysInSecretStorage:i,privateKeysCachedLocally:{masterKey:!!(null==n?void 0:n.hasMaster),userSigningKey:!!(null==n?void 0:n.hasUserSigning),selfSigningKey:!!(null==n?void 0:n.hasSelfSigning)}}})()}createRecoveryKeyFromPassphrase(e){var r=this;return(0,n.A)(function*(){if(e){var t=(0,X.US)(32),i=yield(0,k.wn)(e,t,r.RECOVERY_KEY_DERIVATION_ITERATIONS);return{keyInfo:{passphrase:{algorithm:"m.pbkdf2",iterations:r.RECOVERY_KEY_DERIVATION_ITERATIONS,salt:t}},privateKey:i,encodedPrivateKey:(0,k.jS)(i)}}var n=new Uint8Array(32);return globalThis.crypto.getRandomValues(n),{privateKey:n,encodedPrivateKey:(0,k.jS)(n)}})()}getEncryptionInfoForEvent(e){var r=this;return(0,n.A)(function*(){return r.eventDecryptor.getEncryptionInfoForEvent(e)})()}getVerificationRequestsToDeviceInProgress(e){return this.olmMachine.getVerificationRequests(new o.UserId(e)).filter(e=>void 0===e.roomId&&!e.isCancelled()).map(e=>this.makeVerificationRequest(e))}findVerificationRequestDMInProgress(e,r){if(!r)throw Error("missing userId");var t=this.olmMachine.getVerificationRequests(new o.UserId(r)).find(r=>{var t;return(null==(t=r.roomId)?void 0:t.toString())===e&&!r.isCancelled()});if(t)return this.makeVerificationRequest(t)}requestVerificationDM(e,r){var t=this;return(0,n.A)(function*(){var i=yield t.olmMachine.getIdentity(new o.UserId(e));if(!i)throw Error("unknown userId ".concat(e));try{var n=t._supportedVerificationMethods.map(e=>j(e)),s=yield i.verificationRequestContent(n),a=JSON.parse(s);a.msgtype="m.key.verification.request";var c=JSON.stringify(a),u=yield t.sendVerificationRequestContent(r,c),d=yield i.requestVerification(new o.RoomId(r),new o.EventId(u),n);return t.makeVerificationRequest(d)}finally{i.free()}})()}sendVerificationRequestContent(e,r){var t=this;return(0,n.A)(function*(){var i=(0,X.US)(32),{event_id:n}=yield t.http.authedRequest(p.IT.Put,"/_matrix/client/v3/rooms/".concat(encodeURIComponent(e),"/send/m.room.message/").concat(encodeURIComponent(i)),void 0,r,{prefix:""});return n})()}setSupportedVerificationMethods(e){this._supportedVerificationMethods=null!=e?e:es}requestOwnUserVerification(){var e=this;return(0,n.A)(function*(){var r=yield e.olmMachine.getIdentity(new o.UserId(e.userId));if(void 0===r)throw Error("cannot request verification for this device when there is no existing cross-signing key");try{var[t,i]=yield r.requestVerification(e._supportedVerificationMethods.map(j));return yield e.outgoingRequestProcessor.makeOutgoingRequest(i),e.makeVerificationRequest(t)}finally{r.free()}})()}requestDeviceVerification(e,r){var t=this;return(0,n.A)(function*(){var i=yield t.olmMachine.getDevice(new o.UserId(e),new o.DeviceId(r));if(!i)throw Error("Not a known device");try{var[n,s]=i.requestVerification(t._supportedVerificationMethods.map(j));return yield t.outgoingRequestProcessor.makeOutgoingRequest(s),t.makeVerificationRequest(n)}finally{i.free()}})()}getSessionBackupPrivateKey(){var e=this;return(0,n.A)(function*(){var r=yield e.olmMachine.getBackupKeys();return r.decryptionKey?(0,b.y4)(r.decryptionKey.toBase64()):null})()}storeSessionBackupPrivateKey(e,r){var t=this;return(0,n.A)(function*(){var i=(0,b.WG)(e);if(!r)throw Error("storeSessionBackupPrivateKey: version is required");yield t.backupManager.saveBackupDecryptionKey(o.BackupDecryptionKey.fromBase64(i),r)})()}loadSessionBackupPrivateKeyFromSecretStorage(){var e=this;return(0,n.A)(function*(){var r=yield e.secretStorage.get("m.megolm_backup.v1");if(!r)throw Error("loadSessionBackupPrivateKeyFromSecretStorage: missing decryption key in secret storage");var t=yield e.backupManager.getServerBackupInfo();if(!t||!t.version)throw Error("loadSessionBackupPrivateKeyFromSecretStorage: unable to get backup version");var i=o.BackupDecryptionKey.fromBase64(r);if(!H(i,t))throw Error("loadSessionBackupPrivateKeyFromSecretStorage: decryption key does not match backup info");yield e.backupManager.saveBackupDecryptionKey(i,t.version)})()}getActiveSessionBackupVersion(){var e=this;return(0,n.A)(function*(){return yield e.backupManager.getActiveBackupVersion()})()}getKeyBackupInfo(){var e=this;return(0,n.A)(function*(){return(yield e.backupManager.getServerBackupInfo())||null})()}isKeyBackupTrusted(e){var r=this;return(0,n.A)(function*(){return yield r.backupManager.isKeyBackupTrusted(e)})()}checkKeyBackupAndEnable(){var e=this;return(0,n.A)(function*(){return yield e.backupManager.checkKeyBackupAndEnable(!0)})()}deleteKeyBackupVersion(e){var r=this;return(0,n.A)(function*(){yield r.backupManager.deleteKeyBackupVersion(e)})()}resetKeyBackup(){var e=this;return(0,n.A)(function*(){var r=yield e.backupManager.setupKeyBackup(r=>e.signObject(r));(yield e.secretStorageHasAESKey())&&(yield e.secretStorage.store("m.megolm_backup.v1",r.decryptionKey.toBase64())),e.checkKeyBackupAndEnable()})()}disableKeyStorage(){var e=this;return(0,n.A)(function*(){var r=yield e.getKeyBackupInfo();null!=r&&r.version?yield e.deleteKeyBackupVersion(r.version):e.logger.error("Can't delete key backup version: no version available"),yield e.deleteSecretStorage(),yield e.dehydratedDeviceManager.delete()})()}signObject(e){var r=this;return(0,n.A)(function*(){var t=new Map(Object.entries(e.signatures||{})),i=e.unsigned;delete e.signatures,delete e.unsigned;var n=t.get(r.userId)||{},o=d.stringify(e),s=JSON.parse((yield r.olmMachine.sign(o)).asJSON());t.set(r.userId,eo(eo({},n),s[r.userId])),void 0!==i&&(e.unsigned=i),e.signatures=Object.fromEntries(t.entries())})()}restoreKeyBackupWithPassphrase(e,r){var t=this;return(0,n.A)(function*(){var i=yield t.backupManager.getServerBackupInfo();if(!(null!=i&&i.version))throw Error("No backup info available");var n=yield function(e,r){if(!e.private_key_salt||!e.private_key_iterations)throw Error("Salt and/or iterations not found: this backup cannot be restored with a passphrase");return(0,k.wn)(r,e.private_key_salt,e.private_key_iterations,e.private_key_bits)}(i.auth_data,e);return yield t.storeSessionBackupPrivateKey(n,i.version),t.restoreKeyBackup(r)})()}restoreKeyBackup(e){var r=this;return(0,n.A)(function*(){var t,{decryptionKey:i,backupVersion:n}=yield r.olmMachine.getBackupKeys();if(!i||!n)throw Error("No decryption key found in crypto store");var o=(0,b.y4)(i.toBase64()),s=yield r.backupManager.requestKeyBackupVersion(n);if(!s)throw Error("Backup version to restore ".concat(n," not found on server"));var a=yield r.getBackupDecryptor(s,o);try{return null==e||null==(t=e.progressCallback)||t.call(e,{stage:k.wF.Fetch}),yield r.backupManager.restoreKeyBackup(n,a,e)}finally{a.free()}})()}isDehydrationSupported(){var e=this;return(0,n.A)(function*(){return yield e.dehydratedDeviceManager.isSupported()})()}startDehydration(){var e=arguments,r=this;return(0,n.A)(function*(){var t=e.length>0&&void 0!==e[0]?e[0]:{};if(!(yield r.isCrossSigningReady())||!(yield r.isSecretStorageReady()))throw Error("Device dehydration requires cross-signing and secret storage to be set up");return yield r.dehydratedDeviceManager.start(t||{})})()}importSecretsBundle(e){var r=this;return(0,n.A)(function*(){var t=o.SecretsBundle.from_json(e);yield r.getOlmMachineOrThrow().importSecretsBundle(t)})()}exportSecretsBundle(){var e=this;return(0,n.A)(function*(){var r=yield e.getOlmMachineOrThrow().exportSecretsBundle(),t=r.to_json();return r.free(),t})()}encryptToDeviceMessages(e,r,t){var i=this;return(0,n.A)(function*(){var s,a=new h.Tl(i.logger,"encryptToDeviceMessages"),c=new Set(r.map(e=>{var{userId:r}=e;return r}));yield i.keyClaimManager.ensureSessionsForUsers(a,Array.from(c).map(e=>new o.UserId(e)));var u={batch:[],eventType:v.Bx.RoomMessageEncrypted};return yield Promise.all(r.map((s=(0,n.A)(function*(r){var{userId:n,deviceId:s}=r,a=yield i.olmMachine.getDevice(new o.UserId(n),new o.DeviceId(s));if(a){var c=JSON.parse((yield a.encryptToDeviceEvent(e,t)));u.batch.push({deviceId:s,userId:n,payload:c})}else i.logger.warn("encryptToDeviceMessages: unknown device ".concat(n,":").concat(s))}),function(e){return s.apply(this,arguments)}))),u})()}resetEncryption(e){var r=this;return(0,n.A)(function*(){r.logger.debug("resetEncryption: resetting encryption"),r.dehydratedDeviceManager.delete(),yield r.backupManager.deleteAllKeyBackupVersions(),yield r.deleteSecretStorage(),yield r.crossSigningIdentity.bootstrapCrossSigning({setupNewCrossSigning:!0,authUploadDeviceSigningKeys:e}),yield r.resetKeyBackup(),r.logger.debug("resetEncryption: ended")})()}deleteSecretStorage(){var e=this;return(0,n.A)(function*(){yield e.secretStorage.store("m.cross_signing.master",null),yield e.secretStorage.store("m.cross_signing.self_signing",null),yield e.secretStorage.store("m.cross_signing.user_signing",null),yield e.secretStorage.store("m.megolm_backup.v1",null);var r=yield e.secretStorage.getDefaultKeyId();r&&(yield e.secretStorage.store("m.secret_storage.key.".concat(r),null)),yield e.secretStorage.setDefaultKeyId(null)})()}shareRoomHistoryWithUser(e,r){var t=this;return(0,n.A)(function*(){var i=new h.Tl(t.logger,"shareRoomHistoryWithUser(".concat(e,", ").concat(r,")")),n=yield t.getOwnIdentity();if(!(null!=n&&n.isVerified()))return void i.warn("Not sharing message history as the current device is not verified by our cross-signing identity");i.info("Sharing message history");var s=yield t.getOlmMachineOrThrow().buildRoomKeyBundle(new o.RoomId(e));if(!s)return void i.info("No keys to share");var a=yield t.http.uploadContent(s.encryptedData);i.info("Uploaded encrypted key blob: ".concat(JSON.stringify(a)));var c=t.getOlmMachineOrThrow().queryKeysForUsers([new o.UserId(r)]);for(var u of(yield t.outgoingRequestProcessor.makeOutgoingRequest(c),yield t.keyClaimManager.ensureSessionsForUsers(i,[new o.UserId(r)]),yield t.getOlmMachineOrThrow().shareRoomKeyBundleData(new o.UserId(r),new o.RoomId(e),a.content_uri,s.mediaEncryptionInfo,o.CollectStrategy.identityBasedStrategy())))yield t.outgoingRequestProcessor.makeOutgoingRequest(u)})()}receiveSyncChanges(e){var r=this;return(0,n.A)(function*(){var{events:t,oneTimeKeysCounts:i=new Map,unusedFallbackKeys:n,devices:s=new o.DeviceLists}=e;return yield r.olmMachine.receiveSyncChanges(t?JSON.stringify(t):"[]",s,i,n)})()}preprocessToDeviceMessages(e){var r=this;return(0,n.A)(function*(){var t=yield r.receiveSyncChanges({events:e}),i=[],n=function*(){var e=JSON.parse(s.rawEvent);if(e.type===v.Bx.KeyVerificationRequest){var t=e.sender,n=e.content.transaction_id;n&&t&&r.onIncomingKeyVerificationRequest(t,n)}switch(s.type){case o.ProcessedToDeviceEventType.Decrypted:var a,c,u=s.encryptionInfo;i.push({message:e,encryptionInfo:{sender:u.sender.toString(),senderDevice:null==(c=u.senderDevice)?void 0:c.toString(),senderCurve25519KeyBase64:u.senderCurve25519Key,senderVerified:u.isSenderVerified()}}),"io.element.msc4268.room_key_bundle"===(a=e).type&&"string"==typeof a.content.room_id&&r.roomsPendingKeyBundles.has(e.content.room_id)&&r.maybeAcceptKeyBundle(e.content.room_id,r.roomsPendingKeyBundles.get(e.content.room_id)).then(t=>{t&&r.roomsPendingKeyBundles.delete(e.content.room_id)},t=>{r.logger.error("Error attempting to download key bundle for room ".concat(e.content.room_id)),r.logger.error(t)});break;case o.ProcessedToDeviceEventType.PlainText:i.push({message:e,encryptionInfo:null});case o.ProcessedToDeviceEventType.UnableToDecrypt:case o.ProcessedToDeviceEventType.Invalid:}};for(var s of t)yield*n();return i})()}processKeyCounts(e,r){var t=this;return(0,n.A)(function*(){var i=e&&new Map(Object.entries(e)),n=r&&new Set(r);(void 0!==i||void 0!==n)&&(yield t.receiveSyncChanges({oneTimeKeysCounts:i,unusedFallbackKeys:n}))})()}processDeviceLists(e){var r=this;return(0,n.A)(function*(){var t,i,n=new o.DeviceLists(null==(t=e.changed)?void 0:t.map(e=>new o.UserId(e)),null==(i=e.left)?void 0:i.map(e=>new o.UserId(e)));yield r.receiveSyncChanges({devices:n})})()}onCryptoEvent(e,r){var t=this;return(0,n.A)(function*(){var i=r.getContent(),n=new o.RoomSettings;if("m.megolm.v1.aes-sha2"!==i.algorithm)return void t.logger.warn("Room ".concat(e.roomId,": ignoring crypto event with invalid algorithm ").concat(i.algorithm));n.algorithm=o.EncryptionAlgorithm.MegolmV1AesSha2,i["io.element.msc4362.encrypt_state_events"]&&t.enableEncryptedStateEvents&&(t.logger.info("crypto Enabling state event encryption..."),n.encryptStateEvents=!0);try{n.sessionRotationPeriodMs=i.rotation_period_ms,n.sessionRotationPeriodMessages=i.rotation_period_msgs,yield t.olmMachine.setRoomSettings(new o.RoomId(e.roomId),n)}catch(r){t.logger.warn("Room ".concat(e.roomId,": ignoring crypto event which caused error: ").concat(r));return}var s=t.roomEncryptors[e.roomId];s?s.onCryptoEvent(i):t.roomEncryptors[e.roomId]=new S(t.logger.getChild("[".concat(e.roomId," encryption]")),t.olmMachine,t.keyClaimManager,t.outgoingRequestsManager,e,i)})()}onSyncCompleted(e){this.outgoingRequestsManager.doProcessOutgoingRequests().catch(e=>{this.logger.warn("onSyncCompleted: Error processing outgoing requests",e)})}markAllTrackedUsersAsDirty(){var e=this;return(0,n.A)(function*(){yield e.olmMachine.markAllTrackedUsersAsDirty()})()}onIncomingKeyVerificationRequest(e,r){var t=this.olmMachine.getVerificationRequest(new o.UserId(e),r);t?this.emit(k.cr.VerificationRequestReceived,this.makeVerificationRequest(t)):this.logger.info("Ignoring just-received verification request ".concat(r," which did not start a rust-side verification"))}makeVerificationRequest(e){return new V(this.logger,this.olmMachine,e,this.outgoingRequestProcessor,this._supportedVerificationMethods)}onRoomMembership(e,r,t){var i=this.roomEncryptors[e.getRoomId()];i&&i.onRoomMembership(r)}onRoomKeysUpdated(e){var r=this;return(0,n.A)(function*(){for(var t of e)r.onRoomKeyUpdated(t);r.backupManager.maybeUploadKey()})()}onRoomKeyUpdated(e){var r=this;if(!this.stopped){this.logger.debug("Got update for session ".concat(e.sessionId," from sender ").concat(e.senderKey.toBase64()," in ").concat(e.roomId.toString()));var t=this.eventDecryptor.getEventsPendingRoomKey(e.roomId.toString(),e.sessionId);if(0!==t.length){this.logger.debug("Retrying decryption on events:",t.map(e=>"".concat(e.getId())));var i=function(e){e.attemptDecryption(r,{isRetry:!0}).catch(t=>{r.logger.info("Still unable to decrypt event ".concat(e.getId()," after receiving key"))})};for(var n of t)i(n)}}}onRoomKeysWithheld(e){var r=this;return(0,n.A)(function*(){for(var t of e){r.logger.debug("Got withheld message for session ".concat(t.sessionId," in ").concat(t.roomId.toString()));var i=r.eventDecryptor.getEventsPendingRoomKey(t.roomId.toString(),t.sessionId);if(0===i.length)return;for(var n of(r.logger.debug("Retrying decryption on events:",i.map(e=>"".concat(e.getId()))),i))n.attemptDecryption(r,{isRetry:!0}).catch(e=>{})}})()}onUserIdentityUpdated(e){var r=this;return(0,n.A)(function*(){var t=yield r.getUserVerificationStatus(e.toString());r.emit(k.cr.UserTrustStatusChanged,e.toString(),t),e.toString()===r.userId&&(r.emit(k.cr.KeysChanged,{}),yield r.checkKeyBackupAndEnable())})()}onDevicesUpdated(e){var r=this;return(0,n.A)(function*(){r.emit(k.cr.WillUpdateDevices,e,!1),r.emit(k.cr.DevicesUpdated,e,!1)})()}handleSecretReceived(e,r){var t=this;return(0,n.A)(function*(){return t.logger.debug("onReceiveSecret: Received secret ".concat(e)),"m.megolm_backup.v1"===e&&(yield t.backupManager.handleBackupSecretReceived(r))})()}checkSecrets(e){var r=this;return(0,n.A)(function*(){for(var t of yield r.olmMachine.getSecretsFromInbox(e))if(yield r.handleSecretReceived(e,t))break;yield r.olmMachine.deleteSecretsFromInbox(e)})()}onLiveEventFromSync(e){var r=this;return(0,n.A)(function*(){if(!e.isState()&&!e.getUnsigned().transaction_id){var t,i=(t=(0,n.A)(function*(t){(function(e){switch(e.getType()){case v.Bx.KeyVerificationCancel:case v.Bx.KeyVerificationDone:case v.Bx.KeyVerificationMac:case v.Bx.KeyVerificationStart:case v.Bx.KeyVerificationKey:case v.Bx.KeyVerificationReady:case v.Bx.KeyVerificationAccept:return!0;case v.Bx.RoomMessage:return e.getContent().msgtype===v.Wr.KeyVerificationRequest;default:return!1}})(e)&&(yield r.onKeyVerificationEvent(t))}),function(e){return t.apply(this,arguments)});if(e.isDecryptionFailure()||e.isEncrypted()){var o=setTimeout(()=>e.off(g.OQ.Decrypted,s),3e5),s=(r,t)=>{t||(clearTimeout(o),e.off(g.OQ.Decrypted,s),i(r))};e.on(g.OQ.Decrypted,s)}else yield i(e)}})()}onKeyVerificationEvent(e){var r=this;return(0,n.A)(function*(){var t=e.getRoomId(),i=e.getSender();if(!t)throw Error("missing roomId in the event");if(!i)throw Error("missing sender in the event");r.logger.debug("Incoming verification event ".concat(e.getId()," type ").concat(e.getType()," from ").concat(e.getSender()));var n=e.getType()===v.Bx.RoomMessage&&e.getContent().msgtype===v.Wr.KeyVerificationRequest;if(n){var s=r.getOlmMachineOrThrow().queryKeysForUsers([new o.UserId(i)]);yield r.outgoingRequestProcessor.makeOutgoingRequest(s)}yield r.getOlmMachineOrThrow().receiveVerificationEvent(JSON.stringify({event_id:e.getId(),type:e.getType(),sender:i,state_key:e.getStateKey(),content:e.getContent(),origin_server_ts:e.getTs()}),new o.RoomId(t)),n&&r.onIncomingKeyVerificationRequest(i,e.getId()),r.outgoingRequestsManager.doProcessOutgoingRequests().catch(e=>{r.logger.warn("onKeyVerificationRequest: Error processing outgoing requests",e)})})()}getOwnIdentity(){var e=this;return(0,n.A)(function*(){return yield e.olmMachine.getIdentity(new o.UserId(e.userId))})()}}class ec{constructor(e,r,t){this.logger=e,this.olmMachine=r,this.perSessionBackupDownloader=t,(0,i.A)(this,"eventsPendingKey",new m.kG(()=>new m.kG(()=>new Set)))}attemptEventDecryption(e,r){var t=this;return(0,n.A)(function*(){switch(t.addEventToPendingList(e),r.kind){case k.YH.AllDevicesIsolationMode:i=o.TrustRequirement.Untrusted;break;case k.YH.OnlySignedDevicesIsolationMode:i=o.TrustRequirement.CrossSignedOrLegacy}try{var i,n,s=yield t.olmMachine.decryptRoomEvent(eu(e),new o.RoomId(e.getRoomId()),new o.DecryptionSettings(i));return t.removeEventFromPendingList(e),{clearEvent:JSON.parse(s.event),claimedEd25519Key:s.senderClaimedEd25519Key,senderCurve25519Key:s.senderCurve25519Key,keyForwardedBy:null==(n=s.forwarder)?void 0:n.toString()}}catch(r){if(r instanceof o.MegolmDecryptionError)t.onMegolmDecryptionError(e,r,(yield t.perSessionBackupDownloader.getServerBackupInfo()));else throw new y.O(k.RT.UNKNOWN_ERROR,"Unknown error")}})()}onMegolmDecryptionError(e,r,t){var i=e.getWireContent(),n={sender_key:i.sender_key,session_id:i.session_id};if(r.code===o.DecryptionErrorCode.MissingRoomKey||r.code===o.DecryptionErrorCode.UnknownMessageIndex){this.perSessionBackupDownloader.onDecryptionKeyMissingError(e.getRoomId(),i.session_id);var s=e.getMembershipAtEvent();if(s&&s!==l.O.Join&&s!==l.O.Invite)throw new y.O(k.RT.HISTORICAL_MESSAGE_USER_NOT_JOINED,"This message was sent when we were not a member of the room.",n);if(e.getTs()<=this.olmMachine.deviceCreationTimeMs)if(null===t)throw new y.O(k.RT.HISTORICAL_MESSAGE_NO_KEY_BACKUP,"This message was sent before this device logged in, and there is no key backup on the server.",n);else if(this.perSessionBackupDownloader.isKeyBackupDownloadConfigured())throw new y.O(k.RT.HISTORICAL_MESSAGE_WORKING_BACKUP,"This message was sent before this device logged in. Key backup is working, but we still do not (yet) have the key.",n);else throw new y.O(k.RT.HISTORICAL_MESSAGE_BACKUP_UNCONFIGURED,"This message was sent before this device logged in, and key backup is not working.",n)}if(r.maybe_withheld){var a="The sender has disabled encrypting to unverified devices."===r.maybe_withheld?k.RT.MEGOLM_KEY_WITHHELD_FOR_UNVERIFIED_DEVICE:k.RT.MEGOLM_KEY_WITHHELD;throw new y.O(a,r.maybe_withheld,n)}switch(r.code){case o.DecryptionErrorCode.MissingRoomKey:throw new y.O(k.RT.MEGOLM_UNKNOWN_INBOUND_SESSION_ID,"The sender's device has not sent us the keys for this message.",n);case o.DecryptionErrorCode.UnknownMessageIndex:throw new y.O(k.RT.OLM_UNKNOWN_MESSAGE_INDEX,"The sender's device has not sent us the keys for this message at this index.",n);case o.DecryptionErrorCode.SenderIdentityVerificationViolation:throw this.removeEventFromPendingList(e),new y.O(k.RT.SENDER_IDENTITY_PREVIOUSLY_VERIFIED,"The sender identity is unverified, but was previously verified.");case o.DecryptionErrorCode.UnknownSenderDevice:throw this.removeEventFromPendingList(e),new y.O(k.RT.UNKNOWN_SENDER_DEVICE,"The sender device is not known.");case o.DecryptionErrorCode.UnsignedSenderDevice:throw this.removeEventFromPendingList(e),new y.O(k.RT.UNSIGNED_SENDER_DEVICE,"The sender identity is not cross-signed.");default:throw new y.O(k.RT.UNKNOWN_ERROR,r.description,n)}}getEncryptionInfoForEvent(e){var r=this;return(0,n.A)(function*(){if(!e.getClearContent()||e.isDecryptionFailure())return null;if(null!==e.status)return{shieldColour:k.so.NONE,shieldReason:null};var t=yield r.olmMachine.getRoomEventEncryptionInfo(eu(e),new o.RoomId(e.getRoomId()));return function(e,r){if(void 0===r)return null;var t,i,n=r.shieldState(!1);switch(n.color){case o.ShieldColor.Grey:t=k.so.GREY;break;case o.ShieldColor.None:t=k.so.NONE;break;default:t=k.so.RED}switch(n.code){case void 0:case null:i=null;break;case o.ShieldStateCode.AuthenticityNotGuaranteed:i=k.uV.AUTHENTICITY_NOT_GUARANTEED;break;case o.ShieldStateCode.UnknownDevice:i=k.uV.UNKNOWN_DEVICE;break;case o.ShieldStateCode.UnsignedDevice:i=k.uV.UNSIGNED_DEVICE;break;case o.ShieldStateCode.UnverifiedIdentity:i=k.uV.UNVERIFIED_IDENTITY;break;case o.ShieldStateCode.VerificationViolation:i=k.uV.VERIFICATION_VIOLATION;break;case o.ShieldStateCode.MismatchedSender:i=k.uV.MISMATCHED_SENDER;break;default:i=k.uV.UNKNOWN}return{shieldColour:t,shieldReason:i}}(r.logger,t)})()}getEventsPendingRoomKey(e,r){var t=this.eventsPendingKey.get(e);if(!t)return[];var i=t.get(r);return i?[...i]:[]}addEventToPendingList(e){var r=e.getRoomId();r&&this.eventsPendingKey.getOrCreate(r).getOrCreate(e.getWireContent().session_id).add(e)}removeEventFromPendingList(e){var r=e.getRoomId();if(r){var t=this.eventsPendingKey.getOrCreate(r);if(t){var i=t.get(e.getWireContent().session_id);i&&(i.delete(e),0===i.size&&(t.delete(e.getWireContent().session_id),0===t.size&&this.eventsPendingKey.delete(r)))}}}}function eu(e){return JSON.stringify({event_id:e.getId(),type:e.getWireType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getWireContent(),origin_server_ts:e.getTs()})}var ed=t(69549),el=t(666),eg=t(60332);function ey(){return(ey=(0,n.A)(function*(e){var r,{logger:t,legacyStore:i}=e;if(yield u(),yield i.containsData()){yield i.startup();var n=null;if(yield i.doTxn("readonly",[el.y.STORE_ACCOUNT],e=>{i.getAccount(e,e=>{n=e})}),!n)return void t.debug("Legacy crypto store is not set up (no account found). Not migrating.");var o=yield i.getMigrationState();if(!(o>=ed.Il.MEGOLM_SESSIONS_MIGRATED)){var s=yield function(e,r){return ep.apply(this,arguments)}(t,i),a=yield function(e,r){return ev.apply(this,arguments)}(t,i),c=1+s+a;t.info("Migrating data from legacy crypto store. ".concat(s," olm sessions and ").concat(a," megolm sessions to migrate."));var d=0;g(0);var l=new TextEncoder().encode(e.legacyPickleKey).slice();o===ed.Il.NOT_STARTED&&(t.info("Migrating data from legacy crypto store. Step 1: base data"),yield function(e,r,t,i,n,o,s){return eh.apply(this,arguments)}(e.http,e.userId,e.deviceId,i,l,e.storeHandle,t),o=ed.Il.INITIAL_DATA_MIGRATED,yield i.setMigrationState(o)),g(1),o===ed.Il.INITIAL_DATA_MIGRATED&&(t.info("Migrating data from legacy crypto store. Step 2: olm sessions (".concat(s," sessions to migrate).")),yield function(e,r,t,i,n){return ef.apply(this,arguments)}(t,i,l,e.storeHandle,g),o=ed.Il.OLM_SESSIONS_MIGRATED,yield i.setMigrationState(o)),o===ed.Il.OLM_SESSIONS_MIGRATED&&(t.info("Migrating data from legacy crypto store. Step 3: megolm sessions (".concat(a," sessions to migrate).")),yield function(e,r,t,i,n){return em.apply(this,arguments)}(t,i,l,e.storeHandle,g),o=ed.Il.MEGOLM_SESSIONS_MIGRATED,yield i.setMigrationState(o)),null==(r=e.legacyMigrationProgressListener)||r.call(e,-1,-1),t.info("Migration from legacy crypto store complete")}}function g(r){var t;d+=r,null==(t=e.legacyMigrationProgressListener)||t.call(e,d,c)}})).apply(this,arguments)}function eh(){return(eh=(0,n.A)(function*(e,r,t,i,n,s,a){var c=new o.BaseMigrationData;c.userId=new o.UserId(r),c.deviceId=new o.DeviceId(t),yield i.doTxn("readonly",[el.y.STORE_ACCOUNT],e=>i.getAccount(e,e=>{c.pickledAccount=null!=e?e:""}));var u=yield eS(i,n,"m.megolm_backup.v1");if(u){for(var d=!1,l=null;!d;)try{l=yield J(e),d=!0}catch(e){a.info("Failed to get backup version during migration, retrying in 2 seconds",e),yield(0,m.yy)(2e3)}if(l&&"m.megolm_backup.v1.curve25519-aes-sha2"==l.algorithm)try{var g,y=o.BackupDecryptionKey.fromBase64(u),h=null==(g=l.auth_data)?void 0:g.public_key;y.megolmV1PublicKey.publicKeyBase64==h?(c.backupVersion=l.version,c.backupRecoveryKey=u):a.debug("The backup key to migrate does not match the active backup version","Cached pub key: ".concat(y.megolmV1PublicKey.publicKeyBase64),"Active pub key: ".concat(h))}catch(e){a.warn("Failed to check if the backup key to migrate matches the active backup version",e)}}c.privateCrossSigningMasterKey=yield eS(i,n,"master"),c.privateCrossSigningSelfSigningKey=yield eS(i,n,"self_signing"),c.privateCrossSigningUserSigningKey=yield eS(i,n,"user_signing"),yield o.Migration.migrateBaseData(c,n,s,a)})).apply(this,arguments)}function ep(){return(ep=(0,n.A)(function*(e,r){var t;return e.debug("Counting olm sessions to be migrated"),yield r.doTxn("readonly",[el.y.STORE_SESSIONS],e=>r.countEndToEndSessions(e,e=>t=e)),t})).apply(this,arguments)}function ev(){return(ev=(0,n.A)(function*(e,r){return e.debug("Counting megolm sessions to be migrated"),yield r.countEndToEndInboundGroupSessions()})).apply(this,arguments)}function ef(){return(ef=(0,n.A)(function*(e,r,t,i,n){for(;;){var s=yield r.getEndToEndSessionsBatch();if(null===s)return;e.debug("Migrating batch of ".concat(s.length," olm sessions"));var a=[];for(var c of s){var u=new o.PickledSession;u.senderKey=c.deviceKey,u.pickle=c.session,u.lastUseTime=u.creationTime=new Date(c.lastReceivedMessageTs),a.push(u)}yield o.Migration.migrateOlmSessions(a,t,i,e),yield r.deleteEndToEndSessionsBatch(s),n(s.length)}})).apply(this,arguments)}function em(){return(em=(0,n.A)(function*(e,r,t,i,n){for(;;){var s=yield r.getEndToEndInboundGroupSessionsBatch();if(null===s)return;e.debug("Migrating batch of ".concat(s.length," megolm sessions"));var a=[];for(var c of s){var u,d=c.sessionData,l=new o.PickledInboundGroupSession;l.pickle=d.session,l.roomId=new o.RoomId(d.room_id),l.senderKey=c.senderKey,l.senderSigningKey=null==(u=d.keysClaimed)?void 0:u.ed25519,l.backedUp=!c.needsBackup,l.imported=!0===d.untrusted,a.push(l)}yield o.Migration.migrateMegolmSessions(a,t,i,e),yield r.deleteEndToEndInboundGroupSessionsBatch(s),n(s.length)}})).apply(this,arguments)}function ek(){return(ek=(0,n.A)(function*(e){var{logger:r,legacyStore:t,olmMachine:i}=e;if((yield t.containsData())&&!((yield t.getMigrationState())>=ed.Il.ROOM_SETTINGS_MIGRATED)){var n={};for(var[s,a]of(yield t.doTxn("readwrite",[el.y.STORE_ROOMS],e=>{t.getEndToEndRooms(e,e=>{n=e})}),r.debug("Migrating ".concat(Object.keys(n).length," sets of room settings")),Object.entries(n)))try{var c=new o.RoomSettings;if("m.megolm.v1.aes-sha2"!==a.algorithm){r.warn("Room ".concat(s,": ignoring room with invalid algorithm ").concat(a.algorithm));continue}c.algorithm=o.EncryptionAlgorithm.MegolmV1AesSha2,c.sessionRotationPeriodMs=a.rotation_period_ms,c.sessionRotationPeriodMessages=a.rotation_period_msgs,yield i.setRoomSettings(new o.RoomId(s),c)}catch(e){r.warn("Room ".concat(s,": ignoring settings ").concat(JSON.stringify(a)," which caused error ").concat(e))}r.debug("Completed room settings migration"),yield t.setMigrationState(ed.Il.ROOM_SETTINGS_MIGRATED)}})).apply(this,arguments)}function eS(e,r,t){return eb.apply(this,arguments)}function eb(){return(eb=(0,n.A)(function*(e,r,t){var i=yield new Promise(r=>{e.doTxn("readonly",[el.y.STORE_ACCOUNT],i=>{e.getSecretStorePrivateKey(i,r,t)})});return i&&i.ciphertext&&i.iv&&i.mac?yield(0,eg.A)(i,r,t):i instanceof Uint8Array?(0,b.WG)(i):void 0})).apply(this,arguments)}function eR(){return(eR=(0,n.A)(function*(e){var{legacyCryptoStore:r,rustCrypto:t,logger:i}=e,n=yield t.getOwnIdentity();if(!(!n||n.isVerified())){var o=yield function(e){return ew.apply(this,arguments)}(r);if(o){var s=JSON.parse(n.masterKey);if(!s.keys||0===Object.keys(s.keys).length)return void i.error("Post Migration | Unexpected error: no master key in the rust session.");var a=Object.values(s.keys)[0];a&&a==o&&(i.info("Post Migration: Migrating legacy trusted MSK: ".concat(o," to locally verified.")),yield n.verify())}}})).apply(this,arguments)}function ew(){return(ew=(0,n.A)(function*(e){var r=null;return yield e.doTxn("readonly","account",t=>{e.getCrossSigningKeys(t,e=>{var t=null==e?void 0:e.master;t&&0!=Object.keys(t.keys).length&&(r=Object.values(t.keys)[0])})}),r})).apply(this,arguments)}function eI(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);r&&(i=i.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,i)}return t}function eK(e){return eE.apply(this,arguments)}function eE(){return(eE=(0,n.A)(function*(e){var r,{logger:t}=e;t.debug("Initialising Rust crypto-sdk WASM artifact"),yield u(),t.debug("Opening Rust CryptoStore"),r=e.storePrefix?e.storeKey?yield o.StoreHandle.openWithKey(e.storePrefix,e.storeKey,t):yield o.StoreHandle.open(e.storePrefix,e.storePassphrase,t):yield o.StoreHandle.open(null,null,t),e.legacyCryptoStore&&(yield function(e){return ey.apply(this,arguments)}(function(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?eI(Object(t),!0).forEach(function(r){(0,i.A)(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):eI(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}({legacyStore:e.legacyCryptoStore,storeHandle:r},e)));var n=yield function(e,r,t,i,n,o,s,a,c){return eM.apply(this,arguments)}(t,e.http,e.userId,e.deviceId,e.secretStorage,e.cryptoCallbacks,r,e.legacyCryptoStore,e.enableEncryptedStateEvents);return r.free(),t.debug("Completed rust crypto-sdk setup"),n})).apply(this,arguments)}function eM(){return(eM=(0,n.A)(function*(e,r,t,i,n,s,a,c,u){e.debug("Init OlmMachine");var d=yield o.OlmMachine.initFromStore(new o.UserId(t),new o.DeviceId(i),a,e);c&&(yield function(e){return ek.apply(this,arguments)}({logger:e,legacyStore:c,olmMachine:d})),d.roomKeyRequestsEnabled=!1;var l=new ea(e,d,r,t,i,n,s,u);if(yield d.registerRoomKeyUpdatedCallback(e=>l.onRoomKeysUpdated(e)),yield d.registerRoomKeysWithheldCallback(e=>l.onRoomKeysWithheld(e)),yield d.registerUserIdentityUpdatedCallback(e=>l.onUserIdentityUpdated(e)),yield d.registerDevicesUpdatedCallback(e=>l.onDevicesUpdated(e)),l.checkSecrets("m.megolm_backup.v1"),yield d.registerReceiveSecretCallback((e,r)=>l.checkSecrets(e)),yield d.outgoingRequests(),c&&(yield c.containsData())&&(yield c.getMigrationState())<ed.Il.INITIAL_OWN_KEY_QUERY_DONE){e.debug("Performing initial key query after migration");for(var g=!1;!g;)try{yield l.userHasCrossSigningKeys(t),g=!0}catch(r){e.error("Failed to check for cross-signing keys after migration, retrying",r)}yield function(e){return eR.apply(this,arguments)}({legacyCryptoStore:c,rustCrypto:l,logger:e}),yield c.setMigrationState(ed.Il.INITIAL_OWN_KEY_QUERY_DONE)}return l})).apply(this,arguments)}}}]);